[{"content":"在开发QQ机器人项目的过程中，我经历了一次颇具戏剧性的性能问题排查。这次乌龙事件不仅让我对Python的装饰器机制有了更深入的理解，也让我明白了细节对于程序性能的重要性。在此，我想分享整个排查过程，并深入探讨Python的装饰器。\n问题的起因 为了提高代码的复用性和可维护性，我在项目中广泛使用了Python的装饰器，来实现鉴权、计算函数运行时间、捕获异常、限速、超时重试、屏蔽词过滤等功能。\n某天，当我完成这些装饰器的更新后，重新运行机器人，意外地发现：原本仅需3到5秒就能回复消息的机器人，竟需要等待十几二十秒才能响应。这种明显的性能下降引起了我的注意。\n初步排查 面对这个问题，我首先怀疑是程序内部逻辑出了问题。为了找到可能的异常，我在与消息处理相关的各个位置添加了日志。然而，日志显示程序运行正常，没有任何异常信息。\n接下来，我怀疑是否是系统资源瓶颈导致的。于是，我检查了电脑的内存占用和硬盘I/O，结果它们都在正常范围内。而且，项目使用的是以高性能著称的MongoDB数据库，理论上应该不会成为瓶颈。\n为了彻底排除数据库的问题，我尝试在消息数据和数据库之间增加一层缓存，直接使用内存来保存消息队列。然而，这并没有改善速度，机器人回复仍然需要十几秒。\n灵光一闪 一系列的排查未能找到问题所在，让我一度陷入迷茫。突然，我灵光一闪，想到可以设计一个新的装饰器，用来计算函数的执行时间，从而精确定位问题。\n于是，我编写了一个计算函数执行时间的装饰器，并将其应用在所有涉及网络通信、I/O操作、内存读写、进程间通信和线程切换的函数上，逐一排查性能瓶颈。\n1def async_timed(): 2 \u0026#34;\u0026#34;\u0026#34;计算异步函数执行时间的装饰器\u0026#34;\u0026#34;\u0026#34; 3 def decorator(func): 4 @wraps(func) 5 async def wrapper(*args, **kwargs): 6 start = asyncio.get_event_loop().time() 7 result = await func(*args, **kwargs) 8 end = asyncio.get_event_loop().time() 9 logger.debug(f\u0026#34;函数 {func.__name__} 执行时间: {end - start:.2f} 秒\u0026#34;) 10 return result 11 return wrapper 12 return decorator 通过这个装饰器，我发现网络通信部分正常，耗时在3到5秒之间；其他与计算机相关的操作耗时也很短。真正的问题出现在消息的处理和发送部分。\n问题的根源 原来，为了控制机器人发消息的速度，防止被服务器认为是刷屏，我在处理和发送消息的函数上添加了一个限速装饰器。最初的限速装饰器实现如下：\n1def rate_limit(calls: int, period: float): 2 \u0026#34;\u0026#34;\u0026#34;限速装饰器\u0026#34;\u0026#34;\u0026#34; 3 semaphore = asyncio.Semaphore(calls) 4 5 def decorator(func): 6 @wraps(func) 7 async def wrapper(*args, **kwargs): 8 async with semaphore: 9 result = await func(*args, **kwargs) 10 await asyncio.sleep(period / calls) 11 return result 12 return wrapper 13 return decorator 这个实现存在一个严重问题：在每次函数执行后，都强制\nawait asyncio.sleep(period / calls)\n，这会导致函数阻塞，从而严重影响了机器人的响应速度。\n解决方案 意识到问题所在后，我决定重新设计限速装饰器，采用更为高效的令牌桶算法（Token Bucket Algorithm），以避免阻塞。\n新的限速装饰器实现 1import time 2import asyncio 3from functools import wraps 4 5def rate_limit(calls: int, period: float): 6 \u0026#34;\u0026#34;\u0026#34;限速装饰器，使用令牌桶算法控制调用频率\u0026#34;\u0026#34;\u0026#34; 7 max_tokens = calls # 令牌桶的容量 8 tokens = calls # 当前令牌数 9 refill_time = period / calls # 每个令牌的填充时间 10 last_check = time.time() # 上次检查的时间 11 lock = asyncio.Lock() # 异步锁，确保线程安全 12 13 def decorator(func): 14 @wraps(func) 15 async def wrapper(*args, **kwargs): 16 nonlocal tokens, last_check 17 async with lock: 18 current = time.time() 19 # 计算自上次检查后应添加的令牌数 20 elapsed = current - last_check 21 refill = elapsed / refill_time 22 if refill \u0026gt; 0: 23 tokens = min(tokens + refill, max_tokens) 24 last_check = current 25 if tokens \u0026gt;= 1: 26 tokens -= 1 27 else: 28 # 计算需要等待的时间 29 wait_time = refill_time - elapsed % refill_time 30 await asyncio.sleep(wait_time) 31 return await wrapper(*args, **kwargs) 32 return await func(*args, **kwargs) 33 return wrapper 34 return decorator 算法详解 变量初始化：\nmax_tokens：令牌桶的最大容量。 tokens：当前令牌数，初始为满值。 refill_time：每个令牌的重新填充时间。 last_check：上次检查令牌的时间。 lock：异步锁，确保多协程环境下的线程安全。 令牌更新逻辑：\n计算时间差 elapsed，根据时间差计算新增加的令牌数 refill。 更新当前令牌数 tokens，并确保不超过最大容量。 更新 last_check 时间。 处理请求：\n如果有足够的令牌（tokens \u0026gt;= 1），则扣除一个令牌，直接执行函数。 如果令牌不足，则计算需要等待的时间 wait_time，异步等待后递归调用 wrapper。 应用新的装饰器 将新的限速装饰器应用到消息发送函数上：\n1@rate_limit(calls=10, period=60) # 限速，每分钟最多10次调用 2async def send_msg(msg_type, number, msg, use_voice=False, is_error_message=False): 3 # 消息发送逻辑 4 # ... 这样，在不阻塞其他协程的情况下，成功地限制了消息发送的频率，机器人回复速度恢复正常。\n进一步的装饰器应用 在项目中，我还使用了其他装饰器，如过滤敏感词、处理异常等。\n过滤消息装饰器 1def filter_message(func): 2 \u0026#34;\u0026#34;\u0026#34;过滤消息的装饰器\u0026#34;\u0026#34;\u0026#34; 3 @wraps(func) 4 async def wrapper(message, *args, **kwargs): 5 if isinstance(message, dict): 6 content = message.get(\u0026#39;text\u0026#39;, \u0026#39;\u0026#39;) 7 # 如果是系统消息，跳过检查 8 if message.get(\u0026#39;role\u0026#39;) == \u0026#39;system\u0026#39;: 9 return await func(message, *args, **kwargs) 10 else: 11 content = str(message) 12 13 blocked_word = word_filter.contains_blocked_word(content) # 你可以先把屏蔽词放进一个json或者yaml文件里，然后写一个读取的函数 14 if blocked_word: 15 logger.warning(f\u0026#34;检测到敏感词\u0026#39;{blocked_word}\u0026#39;，消息已被过滤。\u0026#34;) 16 return None # 或者返回特定的提示消息 17 18 return await func(message, *args, **kwargs) 19 return wrapper 该装饰器在消息处理函数执行前，检测消息内容是否包含敏感词，若包含则过滤掉，确保消息的合规性。\n异常处理装饰器 1def error_handler(func): 2 \u0026#34;\u0026#34;\u0026#34;捕获并处理异常的装饰器\u0026#34;\u0026#34;\u0026#34; 3 @wraps(func) 4 async def wrapper(*args, **kwargs): 5 try: 6 return await func(*args, **kwargs) 7 except Exception as e: 8 logger.error(f\u0026#34;执行函数 {func.__name__} 时发生异常：{e}\u0026#34;, exc_info=True) 9 # 根据需要返回特定的错误提示 10 return \u0026#34;抱歉，处理您的请求时出现错误。\u0026#34; 11 return wrapper 这个装饰器捕获异步函数执行过程中可能出现的异常，防止程序崩溃，并提供统一的错误处理机制。\n鉴权装饰器 1def admin_only(func): 2 \u0026#34;\u0026#34;\u0026#34;管理员权限检查装饰器\u0026#34;\u0026#34;\u0026#34; 3 4 @wraps(func) 5 async def wrapper(msg_type, user_info, *args, **kwargs): 6 user_id = user_info[\u0026#39;user_id\u0026#39;] 7 logger.info(f\u0026#34;Checking admin status for user: {user_id}\u0026#34;) 8 9 if str(user_id) != str(config.ADMIN_ID): 10 logger.warning(f\u0026#34;Non-admin user {user_id} attempted to use admin command\u0026#34;) 11 return \u0026#34;对不起，您没有执行此命令的权限。\u0026#34; 12 logger.info(f\u0026#34;Admin command executed by user: {user_id}\u0026#34;) 13 return await func(msg_type, user_info, *args, **kwargs) 14 return wrapper 超时重试装饰器 1def retry(max_retries: int = 3, delay: float = 1.0): 2 \u0026#34;\u0026#34;\u0026#34;重试装饰器\u0026#34;\u0026#34;\u0026#34; 3 4 def decorator(func): 5 @wraps(func) 6 async def wrapper(*args, **kwargs): 7 for attempt in range(max_retries): 8 try: 9 return await func(*args, **kwargs) 10 except Exception as e: 11 if attempt == max_retries - 1: 12 logger.error(f\u0026#34;函数 {func.__name__} 在 {max_retries} 次尝试后仍然失败: {str(e)}\u0026#34;) 13 raise 14 await asyncio.sleep(delay * (2 ** attempt)) # 指数退避 15 return wrapper 16 return decorator 深入理解Python的装饰器 通过这次实践，我对Python的装饰器有了更深入的理解。\n装饰器的本质 装饰器本质上是一个返回函数的函数，它可以在不修改原函数代码的情况下，增加新的功能。装饰器通过对原函数进行包装，控制其输入和输出。\n使用@wraps保持元数据 在编写装饰器时，使用 @functools.wraps(func) 可以保留原函数的元数据，如函数名、注释等。这对于调试和文档生成非常有用。\n装饰器的顺序 当一个函数被多个装饰器装饰时，装饰器的应用顺序是自下而上，即最内层的装饰器先被应用。例如：\n1@decorator_a 2@decorator_b 3def func(): 4 pass 等同于\nfunc = decorator_a(decorator_b(func))\n。\n装饰器在异步函数中的应用 在异步编程中，装饰器需要兼容 async/await 语法。例如，装饰器内部的函数需要使用 async def 定义，并在适当的位置使用 await。\n总结 这次乌龙事件让我深刻体会到细节对程序性能的影响。通过重新设计限速装饰器，采用更合理的算法，不仅解决了性能问题，还加深了我对Python装饰器的理解。\n在开发过程中，使用装饰器可以提高代码的可读性和可维护性，但也需要谨慎，确保装饰器的实现不会引入新的问题。\n最后，希望我的分享能对大家有所帮助。如果你也有类似的经验或想法，欢迎在评论区与我交流！\n","date":"2024-10-18T17:17:39+08:00","permalink":"http://localhost:1313/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E9%99%90%E9%80%9F%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%8C%E9%BE%99%E4%BA%8B%E4%BB%B6/","title":"记一次开发过程中涉及性能问题分析的乌龙事件，顺便谈谈python的装饰器"},{"content":" 系统性能监控笔记 目录 Linux 系统负载监控 网络监控 磁盘与 IO 监控 内存监控 系统性能分析工具 1. Linux 系统负载监控 查看系统负载 uptime 显示系统的负载平均值。 1uptime top 动态显示系统的进程和负载信息。 1top load average 的含义 Load average 是系统在 1 分钟、5 分钟、15 分钟内的平均负载。 2. 网络监控 查看网络连接状态 netstat 显示网络连接、路由表、接口统计信息。 1netstat -an ss 替代 netstat 的工具，更加快速。 1ss -antp 查看带宽使用情况 iftop 实时监控网络流量。 1iftop nload 监控网络接口带宽使用情况。 1nload 3. 磁盘与 IO 监控 查看磁盘空间 df 显示磁盘使用情况。 1df -h du 显示文件和目录的磁盘使用情况。 1du -sh \u0026lt;directory\u0026gt; 监控 IO 性能 iostat 监控 CPU 和设备的 IO 统计。 1iostat iotop 实时查看磁盘 IO 使用情况。 1iotop 4. 内存监控 查看内存使用情况 free 显示系统的内存使用情况。 1free -m vmstat 报告虚拟内存统计信息。 1vmstat top 在 top 命令中查看内存使用情况。 5. 系统性能分析工具 sar 收集、报告和保存系统活动信息。 1sar -u 1 3 # 每秒收集一次 CPU 使用率，连续三次 htop 类似 top，但提供了更好的 UI 和更多功能。 1htop perf Linux 性能分析工具，用于剖析 CPU 使用情况和应用性能。 1perf top ","date":"2024-09-25T23:04:42+08:00","permalink":"http://localhost:1313/posts/%E8%BF%90%E7%BB%B4%E5%B2%97%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84sre%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9F%A5%E8%AF%86/","title":"运维岗需要掌握的SRE和系统性能监控知识"},{"content":" Redis 运维笔记 目录 Redis 基本概念 Redis 持久化机制 Redis 高可用 Redis 常用命令 Redis 性能优化 1. Redis 基本概念 Redis 是什么？ Redis 是一个开源的内存数据结构存储系统，支持多种数据结构如：字符串、哈希、列表、集合、有序集合等。 Redis 提供持久化机制，可以将内存中的数据保存到磁盘中，重启时加载使用。 Redis 应用场景 缓存: 提高访问速度，减少数据库压力。 分布式锁: 利用 Redis 的原子操作实现高效分布式锁。 消息队列: 利用列表结构实现高效队列。 2. Redis 持久化机制 Redis 支持两种主要的持久化方式：\n1. RDB (Redis Database Backup) 原理: 在指定时间间隔内生成数据快照并保存到磁盘。\n优点: RDB 文件紧凑，适合备份。\n缺点: 数据不是实时持久化，可能丢失部分数据。\n配置示例:\n1save 900 1 2save 300 10 3save 60 10000 2. AOF (Append-Only File) 原理: 记录每次写操作，以日志的形式追加到文件中。\n优点: 数据持久化更实时，默认每秒保存一次。\n缺点: AOF 文件比 RDB 更大，恢复速度较慢。\n配置示例:\n1appendonly yes 2appendfsync everysec 选择合适的持久化方式 RDB: 用于备份，适合在不要求实时性但需要快速恢复的场景。 AOF: 用于数据更实时的持久化，但需要更多的磁盘资源。 3. Redis 高可用 1. 主从复制 (Master-Slave Replication) Redis 支持异步复制，一个 Master 可以有多个 Slave。 Slave 只读，接收 Master 数据的更新。 命令: 1SLAVEOF \u0026lt;master-ip\u0026gt; \u0026lt;master-port\u0026gt; 2. 哨兵模式 (Sentinel) 实现高可用性，哨兵可以监控主从实例的运行状态，并在主节点故障时自动进行故障转移。 优点: 自动故障切换，监控实例状态。 配置文件: 1sentinel monitor mymaster 127.0.0.1 6379 2 3. Redis 集群 (Redis Cluster) 分布式: 将数据分布在多个节点上，支持水平扩展。 哈希槽 (Hash Slot): Redis 集群通过哈希槽将数据分布在多个节点，集群默认有 16384 个槽。 支持自动分片和故障转移。 4. Redis 常用命令 键管理 查看所有键:\n1KEYS * 删除键:\n1DEL \u0026lt;key\u0026gt; 字符串操作 设置键值:\n1SET \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 获取键值:\n1GET \u0026lt;key\u0026gt; 列表操作 添加元素到列表:\n1LPUSH \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 获取列表元素:\n1LRANGE \u0026lt;key\u0026gt; 0 -1 哈希操作 设置哈希字段:\n1HSET \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt; 获取哈希字段:\n1HGET \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; 集合操作 添加元素到集合:\n1SADD \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 获取集合所有元素:\n1SMEMBERS \u0026lt;key\u0026gt; 有序集合操作 添加元素到有序集合:\n1ZADD \u0026lt;key\u0026gt; \u0026lt;score\u0026gt; \u0026lt;value\u0026gt; 获取有序集合元素:\n1ZRANGE \u0026lt;key\u0026gt; 0 -1 5. Redis 性能优化 1. 使用缓存 合理设置缓存过期时间，避免占用过多内存。 配置示例: 1maxmemory 2gb 2maxmemory-policy allkeys-lru 2. 数据分区 使用 Redis 集群，将数据分散到不同节点，减少单个节点的压力。 3. 禁用 AOF 或调整 AOF 策略 如果对数据一致性要求不高，可以禁用 AOF 或调整为 everysec 以提高性能。 4. 优化 Redis 配置 增加后台线程，调整 io-threads 来提升并发性能。 ","date":"2024-09-25T23:03:33+08:00","permalink":"http://localhost:1313/posts/%E8%BF%90%E7%BB%B4%E5%B2%97%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84redis%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/","title":"运维岗需要掌握的Redis基础和优化技巧"},{"content":"数据库运维笔记 目录 数据库基本概念 MySQL 基本操作 高可用解决方案 常见 SQL 语句 数据库备份与恢复 数据库性能优化 1. 数据库基本概念 ACID 特性 Atomicity（原子性）: 事务的所有操作要么全部完成，要么全部不完成。 Consistency（一致性）: 事务执行前后，数据库处于一致状态。 Isolation（隔离性）: 并发事务互不干扰。 Durability（持久性）: 事务一旦提交，修改将永久保存。 数据库引擎 InnoDB: 支持事务，支持外键，提供崩溃恢复功能。 MyISAM: 不支持事务，速度快，适用于读多写少的应用。 2. MySQL 基本操作 启动与停止 MySQL 服务 启动服务\n1systemctl start mysqld 停止服务\n1systemctl stop mysqld 登录 MySQL 1mysql -u root -p 数据库管理 创建数据库\n1CREATE DATABASE db_name; 删除数据库\n1DROP DATABASE db_name; 用户管理 创建用户\n1CREATE USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; 删除用户\n1DROP USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; 3. 高可用解决方案 主从复制 (Master-Slave Replication) 主服务器 (Master): 负责处理写操作，数据变化会传递给从服务器。 从服务器 (Slave): 负责处理读操作，并同步主服务器的数据。 双主复制 (Master-Master Replication) 两个服务器互为主服务器，支持双向数据同步。 PXC (Percona XtraDB Cluster) 或 Galera Cluster 提供多主复制，所有节点都能读写，实现真正的高可用。 Keepalived + MySQL: 通过虚拟 IP 实现 MySQL 的高可用性，保证数据库服务不间断。 4. 常见 SQL 语句 数据查询 查询所有数据\n1SELECT * FROM table_name; 查询指定条件的数据\n1SELECT * FROM table_name WHERE condition; 数据插入 插入数据到表中 1INSERT INTO table_name (column1, column2) VALUES (value1, value2); 数据更新 更新表中的数据 1UPDATE table_name SET column1 = value1 WHERE condition; 数据删除 删除表中的数据 1DELETE FROM table_name WHERE condition; 表结构管理 创建表\n1CREATE TABLE table_name ( 2 column1 datatype, 3 column2 datatype, 4 ... 5); 删除表\n1DROP TABLE table_name; 修改表结构\n1ALTER TABLE table_name ADD column_name datatype; 5. 数据库备份与恢复 备份 使用 mysqldump 进行数据库备份 1mysqldump -u root -p database_name \u0026gt; backup.sql 恢复 从备份文件恢复数据库\n1mysql -u root -p database_name \u0026lt; backup.sql 恢复所有数据库\n1mysql -u root -p \u0026lt; alldatabases_backup.sql 增量备份 使用 binlog 进行增量备份 1mysqlbinlog binlog.000001 \u0026gt; incremental_backup.sql 6. 数据库性能优化 索引优化 使用索引加速查询\n1CREATE INDEX idx_name ON table_name (column_name); 查看表的索引\n1SHOW INDEX FROM table_name; 删除索引\n1DROP INDEX idx_name ON table_name; 查询优化 避免使用 SELECT *，只查询需要的字段。 使用 EXPLAIN 语句分析查询语句的执行计划。 1EXPLAIN SELECT * FROM table_name WHERE condition; 表优化 对表进行碎片整理，提升性能 1OPTIMIZE TABLE table_name; 缓存优化 使用查询缓存减少重复查询，提升性能。 启用查询缓存： 在 MySQL 配置文件 my.cnf 中添加 1query_cache_type = 1 2query_cache_size = 64M ","date":"2024-09-25T23:03:02+08:00","permalink":"http://localhost:1313/posts/%E8%BF%90%E7%BB%B4%E5%B2%97%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%92%8C%E8%B0%83%E4%BC%98%E6%8A%80%E5%B7%A7/","title":"运维岗需要掌握的数据库基础和调优技巧"},{"content":" Kubernetes (K8s) 运维笔记 目录 Kubernetes 基础概念 Pod 生命周期管理 Kubernetes 常用命令 K8s 资源管理 网络插件 调度与负载均衡 Kubernetes 高可用性 1. Kubernetes 基础概念 K8s 核心组件 组件 描述 Pod 最小的部署单元，封装一个或多个容器 Node 集群中的单个计算节点，运行 Pod 和代理服务 Cluster 一组 Node，协调资源的调度和管理 Kube-apiserver 集群的入口点，处理 REST 请求 etcd 用于存储集群的状态数据 Kube-scheduler 负责 Pod 的调度到 Node Kube-controller-manager 负责管理控制器，实现自动化控制 Kubelet 运行在每个 Node 上，管理 Pod 和容器 Kube-proxy 处理网络规则，负载均衡 Pod 请求 2. Pod 生命周期管理 Pod 生命周期阶段 Pending: Pod 被创建，但未绑定到 Node。 Running: Pod 已绑定到 Node 并启动了容器。 Succeeded: 所有容器成功完成并退出。 Failed: 某些容器异常终止并退出。 Unknown: 无法与 Node 通信。 Pod 生命周期管理组件 组件 描述 Init Containers 初始化容器，确保主容器启动前某些任务完成 Liveness Probe 健康检查，确保容器存活 Readiness Probe 就绪检查，确保容器可接受流量 Startup Probe 启动检查，确保容器启动后运行稳定 3. Kubernetes 常用命令 集群管理命令 查看集群状态\n1kubectl cluster-info 查看所有 Node\n1kubectl get nodes 获取 Pod 详情\n1kubectl describe pod \u0026lt;pod_name\u0026gt; Pod 操作命令 查看所有 Pod\n1kubectl get pods 创建 Pod\n1kubectl run \u0026lt;pod_name\u0026gt; --image=\u0026lt;image_name\u0026gt; 删除 Pod\n1kubectl delete pod \u0026lt;pod_name\u0026gt; 其他常用命令 获取 Service 列表\n1kubectl get svc 获取 Deployment 列表\n1kubectl get deployment 4. K8s 资源管理 资源种类 Pod: Kubernetes 中最小的部署单元。 Service: 用于暴露 Pod 服务，支持负载均衡。 ConfigMap: 存储配置信息，用于 Pod 内配置文件。 Secret: 安全存储敏感信息，例如密码和 API 密钥。 Volume: 用于持久化存储，Pod 重启后数据不会丢失。 命令示例 创建 Deployment\n1kubectl create deployment \u0026lt;name\u0026gt; --image=\u0026lt;image\u0026gt; 删除资源\n1kubectl delete \u0026lt;resource_type\u0026gt; \u0026lt;resource_name\u0026gt; 5. 网络插件 常见网络插件 Flannel: 最基础的网络插件，简单易用。 Calico: 支持网络策略，灵活且性能好。 Weave: 支持自动网络发现和加密。 Cilium: 基于 eBPF，支持细粒度的安全控制。 插件管理 安装 Flannel\n1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 查看网络状态\n1kubectl get pods -n kube-system 6. 调度与负载均衡 K8s 调度算法 RR (Round Robin): 按顺序将请求调度到不同节点。 Least Connections: 将请求调度到连接数最少的节点。 Resource-Based: 根据节点资源使用情况进行调度。 负载均衡 Kubernetes 内置 Service 对 Pod 进行负载均衡。 使用 Ingress 管理外部 HTTP 和 HTTPS 访问。 7. Kubernetes 高可用性 高可用架构 Master 高可用: 通过多 Master 节点保证控制平面高可用。 etcd 高可用: 使用 etcd 集群存储数据，保证高可用。 Node 高可用: 通过节点间冗余，Pod 可以在不同节点上运行，避免单点故障。 水平扩展 使用 Horizontal Pod Autoscaler (HPA) 根据负载自动扩展 Pod。 ","date":"2024-09-25T23:02:34+08:00","permalink":"http://localhost:1313/posts/%E8%BF%90%E7%BB%B4%E5%B2%97%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84k8s%E5%9F%BA%E7%A1%80/","title":"运维岗需要掌握的K8s基础"},{"content":" Linux 基础运维笔记 目录 RPM 包管理 YUM 包管理 文件系统管理 LVM 动态扩容 系统负载查看 磁盘管理与分区 进程管理 网络管理 安全管理 日志管理 1. RPM 包管理 常用命令 操作 命令 查看包文件列表 rpm -ql \u0026lt;package_name\u0026gt; 安装包 rpm -ivh \u0026lt;package.rpm\u0026gt; 升级包 rpm -Uvh \u0026lt;package.rpm\u0026gt; 卸载包 rpm -e \u0026lt;package_name\u0026gt; 查询已安装包 rpm -qa 检查文件来源 rpm -qf \u0026lt;file_path\u0026gt; 验证包 rpm -V \u0026lt;package_name\u0026gt; 示例 1rpm -ql httpd 1rpm -ivh nginx-1.20.1.rpm 2. YUM 包管理 常用命令 操作 命令 列出可用包 yum list available 安装包 yum install \u0026lt;package_name\u0026gt; 更新系统中所有包 yum update 卸载包 yum remove \u0026lt;package_name\u0026gt; 查看包信息 yum info \u0026lt;package_name\u0026gt; 列出已安装的包 yum list installed 清除缓存 yum clean all 示例 1yum install httpd 1yum remove httpd 3. 文件系统管理 挂载与卸载文件系统 挂载文件系统\n1mount \u0026lt;device\u0026gt; \u0026lt;mount_point\u0026gt; 示例：\n1mount /dev/sda1 /mnt 卸载文件系统\n1umount \u0026lt;mount_point\u0026gt; 示例：\n1umount /mnt 查看当前挂载的文件系统\n1df -h 文件系统的创建 创建 ext4 文件系统\n1mkfs.ext4 /dev/sdX 创建 xfs 文件系统\n1mkfs.xfs /dev/sdX 4. LVM 动态扩容 步骤 创建物理卷\n1pvcreate /dev/sdX 创建卷组\n1vgcreate \u0026lt;volume_group_name\u0026gt; /dev/sdX 创建逻辑卷\n1lvcreate -L \u0026lt;size\u0026gt; -n \u0026lt;logical_volume_name\u0026gt; \u0026lt;volume_group_name\u0026gt; 扩展逻辑卷\n1lvextend -L +\u0026lt;size\u0026gt; /dev/\u0026lt;volume_group\u0026gt;/\u0026lt;logical_volume\u0026gt; 扩展文件系统\n对 ext4 文件系统：\n1resize2fs /dev/\u0026lt;volume_group\u0026gt;/\u0026lt;logical_volume\u0026gt; 对 xfs 文件系统：\n1xfs_growfs /dev/\u0026lt;volume_group\u0026gt;/\u0026lt;logical_volume\u0026gt; 5. 系统负载查看 常用命令 命令 描述 top 实时查看系统状态，包括 CPU、内存、任务 htop top 的增强版，提供更丰富的界面和操作 uptime 查看系统启动时间、负载信息 vmstat 查看系统虚拟内存、IO、进程等信息 iostat 查看磁盘 I/O 使用情况 sar 收集系统性能数据，需安装 sysstat 示例 1top 1uptime 1vmstat 6. 磁盘管理与分区 查看磁盘使用情况 1df -h 查看磁盘 I/O 活动 1iostat 磁盘分区工具 fdisk：适用于 MBR 分区格式磁盘\n1fdisk /dev/sda parted：适用于 GPT 分区格式磁盘\n1parted /dev/sda 创建分区 使用 fdisk 创建分区\n1fdisk /dev/sda 使用 parted 创建 GPT 分区\n1parted /dev/sda mklabel gpt 2parted /dev/sda mkpart primary 0% 100% 7. 进程管理 查看进程 1ps -aux 查看进程树 1pstree 杀死进程 正常终止\n1kill \u0026lt;pid\u0026gt; 强制杀死\n1kill -9 \u0026lt;pid\u0026gt; 8. 网络管理 查看网络配置 1ifconfig 查看路由表 1route -n 测试网络连通性 1ping \u0026lt;hostname or IP\u0026gt; 检查端口状态 1netstat -tuln 9. 安全管理 防火墙管理 命令 描述 firewalld 动态防火墙管理工具 iptables 传统防火墙规则配置工具 Firewalld 命令\n启动 Firewalld： 1systemctl start firewalld 允许某端口（如 80 端口）： 1firewall-cmd --permanent --add-port=80/tcp 重启防火墙： 1firewall-cmd --reload iptables 命令\n查看规则： 1iptables -L 允许某端口（如 80 端口）： 1iptables -A INPUT -p tcp --dport 80 -j ACCEPT 用户与权限管理 创建用户\n1useradd \u0026lt;username\u0026gt; 删除用户\n1userdel \u0026lt;username\u0026gt; 修改用户密码\n1passwd \u0026lt;username\u0026gt; 查看当前用户\n1whoami 更改文件权限\n1chmod 755 \u0026lt;file\u0026gt; 更改文件属主\n1chown \u0026lt;owner\u0026gt;:\u0026lt;group\u0026gt; \u0026lt;file\u0026gt; 10. 日志管理 常见日志文件 日志文件 描述 /var/log/messages 通用系统日志 /var/log/secure 安全相关日志（如登录、sudo 操作等） /var/log/dmesg 内核日志 /var/log/boot.log 启动日志 /var/log/httpd/ Apache 日志文件夹 /var/log/nginx/ Nginx 日志文件夹 日志查看与监控 查看日志\n1cat /var/log/messages 实时查看日志\n1tail -f /var/log/messages ","date":"2024-09-25T23:02:00+08:00","permalink":"http://localhost:1313/posts/%E8%BF%90%E7%BB%B4%E5%B2%97%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84linux%E5%91%BD%E4%BB%A4/","title":"运维岗需要掌握的Linux命令"},{"content":"今天来分享一个我自己写的芙宁娜QQ机器人后端，拥有的能力包括但不限于AI聊天、绘画、发送涩图、AI语音、翻唱歌曲等，还兼具上下文功能，支持自定义system_prompt，适配http和反向ws连接。先来一波展示：\n食用方法 直接对话即可 发送发一张，来一张+关键词即可自定义发送涩图，比方说发一张卡芙卡 发送来份涩图，来份色图，再来一张 即可发送随机涩图 发送画一张，生成一张 即可发送AI绘画（如果config.json里有GPT有关的配置，则关键词会调用dalle进行绘画，除dalle外，还支持白嫖bing的AI绘画，需提前将cookie的值填入cookies.json中，只有一个账号的cookie就按字典格式填一个，多个的话可以放进列表里） 发送语音说，``语音回复 +要用语音说的话让机器人发送语音，或者再提示词里提示机器人通过把#voice`标签放在回复的开头，实现更生动地语音回复。 发送点歌+歌曲名进行点歌，支持模糊匹配。 R-18? 该接口的涩图数量足有十几万，其中r18占27.8%，建议公共场合尽量设置为0，2的话，还是不要太相信自己的运气了(问就是惨痛的教训) 命令功能 机器人支持以下命令：\n/help：显示帮助信息。 /reset：重置当前会话。 /character：输出config.json中的character值，也即当前的人设。 /history: 输出之前的条消息记录，默认十条，也可以接空格+数字指定。 /clear:清除消息记录，默认十条，可接空格+数字指定。 /music_list: 获取歌曲列表 /r18 [0, 1, 2]切换涩图接口r18模式，0为关闭，1为开启，2随机 /model [new_model]切换模型，新模型需先在model.json中配置好 语音功能需要本地搭建gpt-sovits，可以参考视频https://b23.tv/9dOdMo6\n这里放上本地搭建语音整合包 GPT-SoVITS-Inference\n部署 接下来是机器人项目的部署，对接QQ使用的是支持onebot协议的llonebot，所以其他类似项目如Lagrange和NapCat也是可以的，这里仅演示llonebot的配置，默认使用反向ws连接\n包含NTQQ，llonebot插件，MongoDB安装包和项目源码的整合包下载整合包并解压\n先双击install_windows.exe安装NTQQ，然后把llonebot.zip复制到NTQQ的插件目录下解压，重启QQ即可在设置里看到有关配置，然后就是填写反向ws监听地址\n1ws://127.0.0.1:8011/ws 然后是双击MongoDB的安装文件，没什么好讲的，安装完成后进入bin目录，打开cmd，输入\n1 mongod --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\log\\mongodb.log --logappend #替换成你自己的对应目录 关闭终端，填写机器人项目的config，config.json里是基础配置\nopenai_api_key: 你的openai_api_key model: 使用的模型，默认为gpt-3.5-turbo self_id：机器人的QQ号。 admin_id：管理员的QQ号。 block_id: 要屏蔽的QQ号。 nicknames：机器人的昵称列表。 system_message：系统消息配置，最重要的是character，相当于机器人的人格。 connection_type: 连接类型，可选http或ws_reverse report_secret: http事件上传密钥。仅使用http连接时需要填写，默认的123456也可以不管 enable_time: 设置定时开启时间 disable_time: 设置定时关闭时间 proxy_api_base: openai_api_key请求地址，默认为https://api.openai.com/v1 system_message：character里填写人设 reply_probability: 当收到的消息中没有nickname时的回复频率，1为每一条都回复，0为仅回复带有nickname的消息，默认0.5 r18: 0为关闭r18，1开启r18，2为随机发送(慎选) audio_save_path: 语音文件保存位置 voice_service_url: 语音接口地址 cha_name：语音接口指定角色 dialogues.json里主要是配置一些固定回答，一般没什么用，除非有什么恶趣味 model.json里主要是非gpt的其他模型的配置，如果填了，会覆盖config.json里GPT的配置需要为OneAPI格式，model里填写的模型名需要现在aviliable_models里填上。vision代表是否支持识图，如果你的模型可以识图就填true(如果使用gpt系列模型，gpt4系列默认允许识图) 视频教程 【芙宁娜QQ机器人搭建教程】 https://www.bilibili.com/video/BV1BBYcekEUs/?share_source=copy_web\u0026vd_source=6f08734cb3a294b6a1e634a3e5b481ca\n获取bing的cookie用于非gpt系列的AI绘图 如果视频无法渲染可以点击链接下载 项目开源仓库 syuchua/MY_QBOT: 一个简单的QQ机器人后端框架 (github.com)\n一些跟芙芙聊天的日常 【谁家傻芙芙连9.8和9.11哪个大都分不清】 https://www.bilibili.com/video/BV1TivWeFEot/?share_source=copy_web\u0026vd_source=6f08734cb3a294b6a1e634a3e5b481ca\n","date":"2024-08-08T15:26:06+08:00","permalink":"http://localhost:1313/posts/%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8A%99%E5%AE%81%E5%A8%9Cqq%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%94%AF%E6%8C%81ai%E8%81%8A%E5%A4%A9%E8%AF%AD%E9%9F%B3%E7%BB%98%E7%94%BB%E5%92%8C%E5%8F%91%E9%80%81%E6%B6%A9%E5%9B%BE%E5%8F%8A%E7%BF%BB%E5%94%B1/","title":"教你搭建一个自己的芙宁娜QQ机器人，支持AI聊天、语音、绘画和发送涩图及翻唱"},{"content":"今天在Linuxdo闲逛时发现一篇帖子，说是使用某个网站+油猴脚本可以实现GPT4o和claude3.5sonnet等一众最新先进大模型的无限制白嫖（暂时），如果不依赖脚本，仅正常登录使用，每天也能进行50次的对话，本着好东西应该分享的原则，水一篇博客，帮大家也用上**\u0026#x1f606;**\n首先是网站地址： https://www.vecmul.com/\n进入后不要登录，先安装这个油猴脚本： https://greasyfork.org/zh-CN/scripts/502074-vecmul%E6%97%A0%E9%99%90%E5%AF%B9%E8%AF%9D\n之后点击编辑\n把下面的代码替换进去：\n1// ==UserScript== 2// @name 将聊天请求计数保持为零 3// @namespace http://tampermonkey.net/ 4// @version 0.5 5// @description 始终将localStorage中chat-request项的计数保持为0 6// @match https://www.vecmul.com/* 7// @grant none 8// ==/UserScript== 9 10(function() { 11 \u0026#39;use strict\u0026#39;; 12 13 function keepCountAtZero() { 14 let chatRequest = localStorage.getItem(\u0026#39;chat-request\u0026#39;); 15 if (chatRequest) { 16 try { 17 let data = JSON.parse(chatRequest); 18 if (data.count !== 0) { 19 data.count = 0; 20 localStorage.setItem(\u0026#39;chat-request\u0026#39;, JSON.stringify(data)); 21 } 22 } catch (e) { 23 console.error(\u0026#39;解析chat-request时出错:\u0026#39;, e); 24 } 25 } 26 } 27 28 // 初始执行 29 keepCountAtZero(); 30 31 // 重写localStorage的setItem方法 32 const originalSetItem = Storage.prototype.setItem; 33 Storage.prototype.setItem = function(key, value) { 34 originalSetItem.call(this, key, value); 35 if (key === \u0026#39;chat-request\u0026#39;) { 36 keepCountAtZero(); 37 } 38 }; 39 40 console.log(\u0026#39;聊天请求计数将始终为零。\u0026#39;); 41})(); 在返回原来那个网站，就可以实现无限制白嫖gpt4o啦，快去试试吧**\u0026#x1f606;**\n","date":"2024-07-29T23:28:18+08:00","permalink":"http://localhost:1313/posts/%E9%80%9A%E8%BF%87%E6%B2%B9%E7%8C%B4%E6%8F%92%E4%BB%B6%E6%97%A0%E9%99%90%E7%99%BD%E5%AB%96vecmulchat%E7%9A%84gpt4oclaude3-5s%E7%AD%89%E6%9C%80%E6%96%B0%E5%A4%A7%E6%A8%A1%E5%9E%8B/","title":"通过油猴插件无限白嫖VecMulChat的gpt4o，claude3.5s等最新大模型"},{"content":"前几天把自己的一个项目扔到了服务器上，用nginx+域名反代了一下ip+端口，测试却发现请求失败，日志里的报错信息显示不支持的请求类型\nwaht? 明明本地跑的好好的啊，一番排查之后才找到问题，我这个项目实际上是一个api接口，只接受POST请求，但nginx的配置文件里有一个return 301步骤把http请求都转发给了https，转发之后，POST请求就变成了GET，查了一些资料，发现原来只要把return301 改成307就好了\n比方说我原本的nginx.conf是这样的：\n1server { 2 3 listen 80; 4 5 server_name yourip.com; 6 7 return 301 https://$host$request_uri; 8 9 } 10 11 12 13 server { 14 15 listen 443 ssl http2; 16 17 server_name yourip.com; 18 19 ssl_certificate /etc/nginx/certs/cert.pem; 20 21 ssl_certificate_key /etc/nginx/certs/key.pem; 22 23 location / { 24 25 proxy_pass http://127.0.0.1:11451; 26 27 proxy_set_header Host $host; 28 29 proxy_set_header X-Real-IP $remote_addr; 30 31 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 32 33 } 34 35 } 只需要改成：\n1server { 2 3 listen 80; 4 5 server_name yourip.com; # 同理，替换为你的域名 6 7 return 307 https://$host$request_uri; 8 9 } 10 11 12 13 server { 14 15 listen 443 ssl http2; 16 17 server_name yourip.com; # 替换域名 18 19 ssl_certificate /etc/nginx/certs/cert.pem; 20 21 ssl_certificate_key /etc/nginx/certs/key.pem; 22 23 location / { 24 25 proxy_pass http://127.0.0.1:5212; 26 27 proxy_set_header Host $host; 28 29 proxy_set_header X-Real-IP $remote_addr; 30 31 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 32 33 } 34 35 } 就可以了。\n","date":"2024-07-11T23:28:04+08:00","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3post%E8%AF%B7%E6%B1%82%E8%A2%ABnginx%E8%BD%AC%E6%8D%A2%E6%88%90get%E7%9A%84%E9%97%AE%E9%A2%98/","title":"解决POST请求被Nginx转换成GET的问题"},{"content":"最近写一个QQ机器人的后端项目，用于对接AI大模型以及一些图片、语音接口，难免要跟各类大模型的api打交道，听说claude更适合角色扮演，而且新出的Claude3.5-sonnet能力甚至超越了GPT-4o,遂一直想要体验一下，但没有国外的实体手机号，所以没有机会。机缘巧合下得知gcp的VertexAI可以白嫖最新的Gemini和Claude，立马来了兴趣，研究后却发现是通过sdk的方式调用的，没有api，但这不是什么大问题，能用就行，实在不行自己写一个本地api服务不就行了吗，说干就干，直接放上仓库地址，如果能帮到您的话不妨给个star鼓励一下：\nhttps://github.com/syuchua/gcp_claude_transfer\n配置1说明都在readme里了，如果有什么不明白的话，欢迎提issue。\n","date":"2024-07-11T23:24:24+08:00","permalink":"http://localhost:1313/posts/%E5%9F%BA%E4%BA%8Egcp%E7%9A%84vertexai%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84claude%E4%B8%AD%E8%BD%ACapi%E6%9C%8D%E5%8A%A1/","title":"基于gcp的VertexAI搭建一个简单的claude中转api服务"},{"content":"事情是这样的，前几天逛b站的时候无意间刷到一个关于芙宁娜AI桌宠的视频，原以为又要高配显卡才能玩，我这连独显都没有的轻薄本压根不敢想，不过点进去才发现原来训练和推理都是在服务端完成的，由up主及赞助商支持，不需要高配电脑，于是本芙厨直接原地垂直入坑！\n原视频链接贴在这里，希望大家多支持下up主: 【大二自研Agent桌宠】一句话，把简单的电脑任务交给芙宁娜完成吧！-哔哩哔哩\n本文一来是对这么好的项目做一个分享(有芙就是好!)，二来是打算当做一个尽可能详细的教程，毕竟加群的时候也遇到过不少电脑小白，甚至连最基本的解压都不会。索性为爱发电的群友也不少，不仅有支援服务器的，支援网盘的，还有帮忙做整合包、写文档、录制视频教程的，鄙人不才，也根据大佬们的整合包写了一个小脚本，用来简化安装。链接如下：\nhttps://cloud.yuchu.me/s/EvsJ\n5月28日更新： 当前最新版为1.6.5版本，而一键脚本和手动安装包都为1.6.4，新版本不再需要运行设置token.1.exe了，且响应更快，要更新的话先运行一键更新.exe，更新完成之后会出现一个一键更新1.6.4可用.exe，再双金运行它，就可升级到1.6.5版本。\n使用一键脚本自动化安装 该脚本适合电脑闲置空间充裕，有独立显卡的用户，下载之后双击即可运行，过程中可能会弹出要登录智谱清言的界面，直接注册登录就行，其他操作基本全自动。另外还有两点需要注意：\n更换本地tts：下载的整合包默认是包含本地语言包的，这个语言包本质上是利用本地的算力进行推理生成语音，如果有好一点的显卡的话语音生成速度会比默认的服务端快不少。要使用的话，只需在软件根目录，即AI桌宠.exe所在目录下(找不到的可以右键桌面的快捷方式，点击\u0026quot;打开文件所在位置“)，找到setting.json，没有.json后缀也不要紧，只要认准这个setting就行，右键记事本打开，找到\u0026quot;tts_location\u0026quot;这一项，把后边引号里的server 改成 local就行。 之后再双击运行根目录下的starttts.bat文件，即可运行本地tts\n更换皮肤包：整合包里同样包含里芙芙全身版的皮肤包，但默认是卡通类的，要更换的话，同样是打开setting，找到\u0026quot;gif\u0026quot;这一项，把引号里的fufu 改成 fufu2即可（貌似现在默认就是fufu2了，所以这一步可有可无）\n手动安装 手动安装这部分适合没有高配显卡、爱折腾、电脑空间不足或者只是安装在容量较小的U盘作为娱乐的朋友，语音等都跑在服务端，本地几乎没有什么占用\n分别下载安装包和皮肤包\n配置足够且想用本地tts的也可以下载整合包\n双击安装包开始安装，安装完成后先在浏览器打开智谱清言官网注册并登录，之后按下键盘的F12(笔记本同时按下左下角的fn和F12)，打开浏览器的开发者工具，再依次点击应用程序，cookie，找到chatglm_refresh_token，点击，全选复制下方Cookie Value里的内容，打开setting，找到\u0026quot;user_token\u0026quot;，把刚刚复制好的内容粘贴到后面的引号里。\n更换皮肤包：把皮肤包下载解压，解压得到的文件夹直接复制到根目录，然后编辑setting就行。\n打开软件：双击桌面的快捷方式或在根目录双击AI桌宠.exe，初次启动可能会有些慢，耐心等待即可。\n常用功能 内存优化 代码编写 桌面识别 播放音乐 申请色色？ 最后，还有什么问题的话，不妨加QQ群来寻找答案哦，里面超多大佬，说话又好听，超喜欢在里面的（） END ","date":"2024-05-19T22:47:41+08:00","permalink":"http://localhost:1313/posts/%E4%BC%9A%E5%94%B1%E6%AD%8C%E7%9A%84%E8%8A%99%E5%AE%81%E5%A8%9Cai%E6%A1%8C%E5%AE%A0%E7%A1%AE%E5%AE%9A%E4%B8%8D%E6%9D%A5%E7%9C%8B%E7%9C%8B%E5%90%97/","title":"会唱歌的芙宁娜AI桌宠，确定不来看看吗？"},{"content":"今天来更一篇关于Windows终端美化的教程，先放个成品：\n实现的效果主要有终端半透明、亚克力材质、背景图片以及终端主题。\n安装PowerShell 7 相比于 Windows 默认提供的 Powershell，Powershell 7 拥有以下几个优势：\n支持跨平台使用，增强了其灵活性和适用范围。 提供了更优越的性能表现。 处于持续更新状态，保证了功能的不断完善和安全性的提升。 简而言之，Powershell 7 是 Powershell 的升级版。 官网地址：\nPowerShell 文档 - PowerShell Github 地址：\nhttps://github.com/PowerShell/PowerShell 下载地址：\nhttps://github.com/PowerShell/PowerShell/releases/ https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows 选择合适自己的安装即可。\n安装Windows Terminal 直接去微软商店下载即可：https://apps.microsoft.com/detail/9n0dx20hk701?hl=zh=CN\u0026amp;gl=CN\n安装winget 一般在Windows10 高于 1709 (Build 16299) 的版本和 Windows11上以及预装了winget，可以通过在命令行输入\n1winget --version 确认，如果没有的话可以在微软商店安装：https://apps.microsoft.com/detail/9nblggh4nns1?hl=zh-CN\u0026amp;gl=CN\n修改透明度、亚克力材质和背景图片 旧版的Windows Terminal需要修改json的配置文件，但新版可以直接在设置界面可视化开启 点击设置-外观 默认值-外观-背景图像路径，可以自定义图片作为终端背景，再往下拉一点，设置图像不透明度，个人喜欢色调偏暗的，就设定为20%了。 再往下拉一点，就是设定终端界面的不透明度和亚克力材质了。 如果想要差异化的，还可以单独设定不同终端的外观。 安装oh-my-posh 直接winget就可以安装\n1winget search oh-my-posh 如果出现两个结果，一个msstore的一个winget的，随便选一个就行。\n设置oh-my-posh主题 在PowerShell中输入\n1code $profile # 没有vscode的话也可以输入notepad $profile 使用记事本打开 在打开的文件中输入这行命令：\n1oh-my-posh init pwsh --config $env:POSH_THEMES_PATH\\peru.omp.json | Invoke-Expression 其中的peru.omp.json即主题配置，可以自行修改，前往C:\\Users\\\u0026lt;用户名\u0026gt;\\AppData\\Local\\Programs\\oh-my-posh\\themes目录下即可查看不同配置，可以依次试用，选一个你喜欢的。\nEND ","date":"2024-05-07T22:05:04+08:00","permalink":"http://localhost:1313/posts/oh-my-posh-%E5%9F%BA%E4%BA%8Ewindowsterminal%E7%9A%84powershell%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/","title":"oh-my-posh:基于WindowsTerminal的powershell美化教程"},{"content":"前几天因为课程需要折腾了一下遗传算法，因为担心老师课上提问，带电脑又不方便，变突发奇想程序能不能在手机上运行，毕竟手机上也是有终端环境——termux的。但是termux毕竟只是终端，无法生成函数图像。你说x11？算了吧，还不如直接上电脑呢。\n于是想到了jupyter——一款支持图像输出的在线强大工具，只需要浏览器就能运行。话不多说，直接上手安装: pip install jupyter 毫无疑问报错了，报的错还看不懂，说是缺了依赖，那我用pkg安装依赖呢？还报错，一会儿说是这个依赖还需要某某依赖，一会又是早轮子报错……没办法，上网找教程吧。\n现实是，网上安装jupyter的教程是不少，可大都是PC端的，termux少得可怜，即便有，也大都是三四年前的，不同的人甚至有不同的解决办法，可这些方法都试过一遍后，也都无一例外的失败了。但功夫不负有心人，最后还是在CSDN上找到一篇接近成功的方法，这里贴出原文链接，以供参考: http://t.csdnimg.cn/r7K6y\n但这篇博客终究还是有一些瑕疵，索性问题都不是很大，只是一些版本兼容性问题，比方说在安装numpy，matplotlib，pandas，jupyter等的时候因为不同的版本之间不一定兼容，动不动会出现一大堆的报错，解决方法也简单，就是把pip换成pkg安装，因为pip安装往往需要经过编译，而编译又需要某些特定的工具和库，大都是termux环境中没有的，pkg安装则是直接安装pkg中预编译好的二进制文件，早已跳过了通过工具链编译这一步。举个简单的例子，比方说我要安装numpy和pandas，就不必使用\n1pip install numpy pandas 或者\n1MATHLIB=\u0026#34;m\u0026#34; pip install pandas 2MATHLIB=\u0026#34;m\u0026#34; pip install numpy 而是换成\n1pkg install -y python-numpy python-pandas 包括在安装jupyter时经常编译出错的pyzmq，也可以这样安装，后面跟上==25.1.1指的是版本，因为pkg和pip总是默认安装最新的，但测试发现目前最新的26.0.2版本(2024年4月底)有兼容问题，遂换成25.1.1版本\n1pkg install -y libzmq libcrypt pkg-config # 先安装一些必要的依赖库 2 3# 再通过pkg安装pyzmq 4 5pkg install -y python-pyzmq==25.1.1 6 7# 或者 8pip install pyzmq==25.1.1 安装jupyter中还有一个经常出现的依赖报错是maturin，这是一个rust里的文件，同样是因为一些版本兼容问题，在Python3.11的环境下是无法正常编译安装的，这个时候就只能先安装rust环境，再用cargo安装了:\n1pkg install rust #安装rust 2pkg install binutils-is-llvm 3cargo install maturin 4pkg install -y libzmq libcrypt pkg-config 5pip install clang fftw make freetype # 一些编译有关依赖 6pip install ipython # jupyter依赖ipython 之后再安装jupyter应该就不会报错了\n1pip install jupyter 安装matplotlib的过程也是常常因为一些依赖报错，但比起jupyter还是简单不少的\n1pkg install -y libjpeg-turbo libtiff 2pkg install python-pillow 3pkg install -y libpng 4pkg install matplotlib 总的来说，在termux里折腾jupyter说难不难，说简单也不简单吧，毕竟也是花了我几个小时的时间，最后，我把上面的过程都写成了一个脚本，方便大家自动化安装，地址如下: https://github.com/syuchua/termux-jupyter\n如果是直接使用的话可以使用wget下载到本地:\n1wget https://raw.githubusercontent.com/syuchua/termux-jupyter/master/install.sh -O install.sh 2chmod +x install.sh 3./install.sh 最后，如果觉得本教程或者这个脚本还可以的话，麻烦给我一个star，谢谢！\n","date":"2024-05-02T22:34:29+08:00","permalink":"http://localhost:1313/posts/termux%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0%E4%B9%8B%E5%AE%89%E8%A3%85jupyternumpypandas%E5%92%8Cmatplotlib/","title":"termux折腾日记之安装jupyter、numpy、pandas和matplotlib"},{"content":"shizuku是什么？ Shizuku 是一款开源的 ADB（Android Debug Briage）权限管理器。由于现阶段大部分安卓手机都无法解锁获取 ROOT 高级权限，但是用户又需要高级权限对系统进行一些操作，恰好这些功能可以通过 ADB 权限进行解决，比如冻结应用、卸载不想要的系统应用（只有少部分能通过adb卸载，更多的还是建议root）。这种情况下，Shizuku 就是一个非常好的解决方案。\n具体关于shizuku是什么，官网已经给出了很明确的解释：Shizuku 可以帮助普通应用借助一个由 app_process 启动的 Java 进程直接以 adb 或 root 特权使用系统 API。简单来说，root权限\u0026gt;shizuku的权限\u0026gt;普通用户，利用这一聊胜于无的权限，我们就已经可以做很多事了。\n安装shizuku 酷安的shizuku下载地址似乎已经被ban了，那就只能用Google play或者github下载了，国内用户访问这两个地址不方便的，也可以使用我的cloudreve\n激活shizuku shizuku官方提供了三种激活方式，root激活，连接电脑通过adb激活和无线调试激活。root激活就不提了，我都root了还折腾shizuku干嘛（笑），adb激活需要手边有电脑，总归是不太方便，而且后面我们还会介绍一种更好的方法。现在我们先演示用无线调试激活。\n打开手机设置-我的设备（也可能是我的手机或其他类似的选项），找到版本号，连续点击至少5次，直到弹出“您已处于开发者模式”的提示。 返回设置-更多设置-开发者选项，启用无线调试。在 Shizuku 软件内开始配对- 点按“无线调试”中的“使用配对码配对设备”- 在下来菜单的Shizuku的通知中填入配对码\n无效调试激活方案注意事项: 如果无法输入配对码，请在系统-通知样式选项中，将默认通知样式改为 原生样式- 启用无线调试的过程中，部分系统会提示「某个应用遮挡了权限请求界面」，可以尝试关闭系统的侧边栏功能或者关闭掉所有允获取了悬浮窗权限的应用 通过黑阈激活 黑阈是一款不需要root就能待机或强行停止应用的工具，它可以配合shizuku实现对一些流氓应用的限制。但这里我们要用到的是它的另一个功能\u0026mdash;指令。\n下载安装黑阈 酷安可以直接下载：https://www.coolapk.com/apk/me.piebridge.brevent\n安装完成后照着上面无线调试激活shizuku的步骤，无线激活黑阈就好了\n激活后点击左上角-执行指令 输入\n1sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh 即可激活shizuku这一步的原理其实与adb激活shizuku类似，不过不需要电脑，好处是适配性更好，也比较方便，仅此更推荐用这种方式激活shizuku。\nshizuku常见用法 使用冰箱冻结应用\n给mt管理器提权，使之能访问Android/data目录\n给scene提权，查看CPU运行状态和检测游戏帧率\n给APP Ops提权，更好地监控和管理app权限，对抗摇一摇广告的神！\n给GKD提权，反开屏广告地神！\n给termux提权，在termux里也能访问Android/data目录\n","date":"2024-04-29T21:09:03+08:00","permalink":"http://localhost:1313/posts/shizuku-%E5%AE%89%E5%8D%93%E7%8E%A9%E6%9C%BA%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","title":"shizuku:安卓玩机入门指南"},{"content":"图床想必大家都不陌生了，无论是个人搭建博客或是其他站点、APP、小程序，还是企业级的应用，想要加速网站的访问，都离不开图床，但一款稳定好用的图床又往往要么是收费的，要么需要实名注册等各种流程，那有没有什么免费且方便的代替方案呢？\n答案是显而易见的，使用GitHub的仓库作为图床，再经由jsdelivr的免费cdn加速，一款稳定方便的图床就诞生了，下面开始本期教程。\n新建GitHub仓库 生成一个token 点击右上角用户头像-\u0026gt; 设置 点击开发者设置 点击Personal acess tokens -\u0026gt; Generate new token 填写token描述，勾选repo即可，过期时间可以选择永不\n获取token秘钥 注意，该秘钥仅显示一次，建议保存到一个找得到的地方，或者云盘，后面还会用到。\n配置PicGo并使用jsdelivr的免费cdn加速 下载PicGo，安装好后开始对接图床\n设定仓库名：username/repositoies(username为github用户名，repositoies为仓库名，比方说用户名zhangsan，仓库名为jsdelivr，就填写zhangsan/jsdelivr)\n设定分支名：main\n设定token：刚刚复制的token\n指定存储路径：填写打算存放图片的位置，比方说img/，代表在该仓库下创建一个铭文img的文件夹，图片将保存在这个文件夹中。\n设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名@分支 #默认是main\n接下来就可以愉快的使用免费图床啦！\nEND ","date":"2024-04-20T16:16:35+08:00","permalink":"http://localhost:1313/posts/%E5%9F%BA%E4%BA%8Egithub-jsdelivr%E5%AE%9E%E7%8E%B0%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/","title":"基于github+jsdelivr实现免费图床"},{"content":"最近一段时间对AI大模型以及各种衍生的生产力工具比较感兴趣，就特别希望有一个all-in-one的产品出现，虽说网上也能各种导航站，但一来信息更新不一定及时，二来还经常有各种广告，且站长们有时候更换域名都不通知一下的，导致过期的域名往往被一些不合法的小网站注册。另外一点是现在国产软件大都臃肿，各种弹窗广告催你贷款，下载某某软件不说，你美团往软件里塞个原神是什么原神，不是，真有人在美团玩原神吗？\n话说回来，现在其实我是比较抗拒在手机上下载一款新软件的，毕竟存储真不太够用了。其他一下纯工具类软件，比方说一个木函之类的，下载似乎也没多大必要，因为实现的都是一些小众的功能，很久才能用上一次，何况大部分还都能被小程序代替。 相反，要是一款本来就是为工作而生，没有那么多花里胡哨的功能和广告的应用，以不大的内存增长为代价，可以实现继承各种有助于提高生产力的功能，那就再好不过了。\n说来也巧，最近刚好在捣鼓阿里开源的Qwen1.5大模型，想办法让它跑在本地而非云端，进而拿自己的数据集和知识库进行训练，但效果并不是太好。突然想起来，大概是去年十月份左右吧，阿里曾说自家的通义千问将会接入钉钉，当时也没太在意，一晃都半年多了。何况这半年来我也几乎没怎么使用过它。于是，昨天试着久违的更新了一下钉钉，发现真的多了不少让人眼前一亮的新特性，一起来看看吧。\n新增钉钉个人版 进入钉钉，点击左上角头像 点击钉钉个人版\n首先映入眼帘的就是这一列AI助理了，都接入了通义千问的大模型，不光文字交流，还能生成图片和视频，感觉还是挺实用的\n左边云盘对接的是你的阿里云盘\n空间这里可以放一下笔记之类的，也可以自己编辑，实测，支持html和markdown语法，感觉有点类似于国外的Notion，Obsidian，Typora，国内的语雀，思源笔记等。\n发现这里有一些有用的小程序\nEND 具体好不好用另说，毕竟我也还没怎么体验，但作为一个ALL-in-One的生产力工具，我还是很喜欢的。\n","date":"2024-04-20T16:00:09+08:00","permalink":"http://localhost:1313/posts/%E4%B8%8D%E6%98%AF%E9%92%89%E9%92%89%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%99%E4%B9%88%E5%BC%BA%E4%BA%86/","title":"不是，钉钉什么时候这么强了？"},{"content":"事情是这样的，压根没学过什么人工智能相关课程的笔者收到了这样一份小组作业： 于是不得不从网上找结局方案（其实就是想吃现成的），发现遗传算法似乎不是很难，而且代码量也不大，而笔者的python又学的好凑合，便决定来用python实现遗传算法，来完成这一小组作业\n遗传算法简介 遗传算法简称GA（Genetic Algorithms）模拟自然界生物遗传学（孟德尔）和生物进化论（达尔文）通过人工方式所构造的一类并行随机搜索最优化方法，是对生物进化过程“优胜劣汰，适者生存”这一过程进行的一种数学仿真。\n其实说白了，这玩意其实大家在高中就接触过了，孟德尔的豌豆实验，摩尔根果蝇实验，本质上都是一种遗传算法的实现（这么说其实不太准确，爸爸像儿子了属于是）,基本思路就是复制-挑选-迭代-挑选-迭代······\n算法特点 直接对结构对象进行操作，不存在求导和函数连续性的限定； 具有内在的隐含并行性和更好的全局寻优能力； 采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应地调整搜索方向，不需要确定的规则。 算法流程 如图： 遗传算法主要执行以下四步：\n随机地建立由字符串组成的初始群体； 计算各个体的适应度； 根据遗传概率，利用下述操作产生新群体： 复制。将已有的优良个体复制后添入新群体中，删除劣质个体； 交换。将选出的两个个体进行交换，所产生的新个体添入新群体中。 突变。随机地改变某一个体的某个字符后添入新群体中。 反复执行（2）、（3）后，一旦达到终止条件，选择最佳个体作为遗传算法的结果。 算法实例 求f(x) = $x^2$ 极大值问题，设自变量 x 介于0～31，求其二次函数的最大值，即：max f(x) = $x^2$, x∈ [0, 31]\n（1）编码 遗传算法首先要对实际问题进行编码，用字符串表达问题。这种字符串相当于遗传学中的染色体。每一代所产生的字符串个体总和称为群体。为了实现的方便，通常字符串长度固定，字符选0或1。 本例中，利用5位二进制数表示x值，采用随机产生的方法，假设得出拥有四个个体的初始群体，即：01101，11000，01000，10011。x值相应为13，24，8，19。\n个体编号 初始群体 Xi 1 01101 13 2 11000 24 3 01000 8 4 10011 19 （2）计算适应度 衡量字符串（染色体）好坏的指标是适应度，它也就是遗传算法的目标函数。本例中用$x^2$计算。\n个体编号 初始群体 Xi 适应度f(Xi) f(Xi)/Εf(Xi) f(Xi)/f Mp 1 01101 13 169 0.14 0.58 1 2 11000 24 576 0.49 1.97 2 3 01000 8 64 0.06 0.22 0 4 10011 19 361 0.31 1.23 1 总计Σf(Xi) 1170 1.00 4.00 4 平均值f 293 0.25 1.00 1 最大值 576 0.49 1.97 2 最小值 64 0.06 0.22 0 表中还列出了当前适应度的总和$∑f(x_i)$及平均值f\n表中第6列的 f(xi)/f 表示每个个体的相对适应度，它反映了个体之间的相对优劣性。如2号个体的 f(xi)/f 值最高（1.97），为优良个体，3号个体最低（0.22），为不良个体。\n（3）复制 根据相对适应度的大小对个体进行取舍，2号个体性能最优，予以复制繁殖。3号个体性能最差，将它删除，使之死亡，表中的M表示传递给下一代的个体数目，其中2号个体占2个，3号个体为0，1号、4号个体保持为1个。这样，就产生了下一代群体\n复制后产生的新一代群体的平均适应度明显增加，由原来的293增加到421 （4）交换 利用随机配对的方法，决定1号和2号个体、3号和4号个体分别交换，如表中第5列。再利用随机定位的方法，确定这两对母体交叉换位的位置分别从字符长度的第4位及第3位开始。如：3号、4号个体从字符长度第3位开始交换。交换开始的位置称交换点\n（5）突变 将个体字符串某位符号进行逆变，即由1变为0或由0变为1。例如，下式左侧的个体于第3位突变，得到新个体如右侧所示。\n遗传算法中，个体是否进行突变以及在哪个部位突变，都由事先给定的概率决定。通常，突变概率很小，本例的第一代中就没有发生突变。\n上述（2）～（5）反复执行，直至得出满意的最优解。\n综上可以看出，遗传算法参考生物中有关进化与遗传的过程，利用复制、交换、突变等操作，不断循环执行，逐渐逼近全局最优解。\n算法实现 （1）编码与解码 将不同的实数表示成不同的0，1二进制串表示就完成了编码，因此我们并不需要去了解一个实数对应的二进制具体是多少，我们只需要保证有一个映射能够将十进制的数编码为二进制即可。而在最后我们肯定要将编码后的二进制串转换为我们理解的十进制串，所以我们需要的是y = f ( x )的逆映射，也就是将二进制转化为十进制，也就是解码，十进制与二进制相互映射的关系以下为例进行说明： 例如 ：对于一个长度为10的二进制串,如[0,0,0,1,0,0,0,0,0,1]，将其映射到[1,3]这个区间 1. 首先将二进制数按权展开：$0 2^9+02^8+02^7+12^6+02^5+02^4+02^3+02^2+02^1+12^0=65$ 2. 然后将其压缩到区间[0,1]：$65/(2^{10} - 1) \\approx0.0635386$ 3. 最后将[0,1]区间的数映射到我们想要的区间[1,3]：$0.0635386*（3-1）+ 1\\approx1.12707722$，可以看出规律为：num * (high-low)+low 其中num为[0,1]之间的数对应此处的0.0635386，high和low表示我们想要映射的区间的上边界和下边界，分别对应此处的3和1。\n现在再来看看编码过程。不难看出上面我们的DNA（二进制串）长为10，10位二进制可以表示$2^{10}$种不同的状态，可以看成是将最后要转化为的十进制区间 [ 1 , 3 ] 切分成$2^{10}$份。可看出，如果我们增加二进制串的长度，那么我们对区间的切分可以更加精细，转化后的十进制解也更加精确。所以DNA长度越长，解码为10进制的实数越精确\n另外需要注意的是一个基因可能存储了多个数据的信息，在进行解码时注意将其分开，如一个基因含有x,y两个数据，该基因型的长度为20，可以用前10位表示x，后10位表示y，解码时分开进行解码。\n（2）适应度 在实际问题中，有时希望适应度越大越好（如赢利、劳动生产率），有时要求适应度越小越好（费用、方差）。为了使遗传算法有通用性，这种最大、最小值问题宜统一表达。通常都统一按最大值问题处理，而且不允许适应度小于0。 对于最小值问题，其适应度按下式转换：\n(3)选择 有了适度函数，然后就可以根据某个基因的适应度函数的值与所有基因适应度的总和的比值作为选择的依据，该值大的个体更易被选择，可以通过有放回的随机采样来模拟选择的过程，有放回的随机采样的方式可以参考我的这篇博客: 随机采样 (4)交叉和变异 交叉和 变异都是随机发生的，对于交叉而言，随机选择其双亲，并随机选择交叉点位，按照一定的概率进行交叉操作。可以通过以下方式实现：首先选择种群中的每个基因作为父亲，然后通过产生一个[0,1]随机数,将其与定义的交叉概率比较，如果小于该数，则在种群中随机选择另外的母亲，随机选择交叉点位进行交叉。 （5）举例 利用遗传算法求Rosenbrock函数的极大值\n算法源码 1import numpy as np # 导入numpy库，用于数学运算 2import matplotlib.pyplot as plt # 导入matplotlib的pyplot模块，用于绘图 3from matplotlib import cm # 导入matplotlib的颜色映射模块 4from mpl_toolkits.mplot3d import Axes3D # 导入3D绘图工具 5 6# 定义遗传算法的参数 7DNA_SIZE = 24 # DNA的长度，即染色体的位数 8POP_SIZE = 80 # 种群的大小，即染色体的数量 9CROSSOVER_RATE = 0.6 # 交叉率，表示种群中有多少比例的个体会进行交叉操作 10MUTATION_RATE = 0.01 # 变异率，表示基因突变的概率 11N_GENERATIONS = 100 # 进化的代数 12X_BOUND = [-2.048, 2.048] # x的取值范围 13Y_BOUND = [-2.048, 2.048] # y的取值范围 14 15# 定义目标函数，即优化问题中的函数 16def F(x, y): 17 return 100.0 * (y - x ** 2.0) ** 2.0 + (1 - x) ** 2.0 18 19# 定义3D绘图函数 20def plot_3d(ax): 21 X = np.linspace(*X_BOUND, 100) # 生成x的等差数列 22 Y = np.linspace(*Y_BOUND, 100) # 生成y的等差数列 23 X, Y = np.meshgrid(X, Y) # 生成网格 24 Z = F(X, Y) # 计算每个点的函数值 25 ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm) # 绘制3D曲面 26 ax.set_xlabel(\u0026#39;x\u0026#39;) # 设置x轴标签 27 ax.set_ylabel(\u0026#39;y\u0026#39;) # 设置y轴标签 28 ax.set_zlabel(\u0026#39;z\u0026#39;) # 设置z轴标签 29 plt.pause(3) # 暂停3秒 30 plt.show() # 显示图形 31 32# 适应度函数，用于评估个体的适应度 33def get_fitness(pop): 34 x, y = translateDNA(pop) # 将DNA转换为x, y坐标 35 pred = F(x, y) # 计算适应度 36 return pred 37 38# DNA转换函数，将二进制编码的DNA转换为实数解 39def translateDNA(pop): 40 x_pop = pop[:, 0:DNA_SIZE] # 提取x坐标的DNA部分 41 y_pop = pop[:, DNA_SIZE:] # 提取y坐标的DNA部分 42 x = x_pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0]) + X_BOUND[0] 43 y = y_pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (Y_BOUND[1] - Y_BOUND[0]) + Y_BOUND[0] 44 return x, y 45 46# 交叉和变异函数 47def crossover_and_mutation(pop, CROSSOVER_RATE=CROSSOVER_RATE): 48 new_pop = [] # 初始化新的种群 49 for father in pop: # 遍历种群中的每一个个体 50 child = father.copy() # 复制个体作为孩子的初始基因 51 if np.random.rand() \u0026lt; CROSSOVER_RATE: # 以交叉率的概率进行交叉 52 mother = pop[np.random.randint(POP_SIZE)] # 随机选择另一个个体作为母亲 53 cross_points = np.random.randint(low=0, high=DNA_SIZE * 2) # 随机选择交叉点 54 child[cross_points:] = mother[cross_points:] # 孩子继承母亲的基因 55 mutation(child) # 对孩子进行变异 56 new_pop.append(child) # 将新个体添加到新种群中 57 return np.array(new_pop) # 返回新的种群 58 59# 变异函数 60def mutation(child, MUTATION_RATE=MUTATION_RATE): 61 if np.random.rand() \u0026lt; MUTATION_RATE: # 以变异率的概率进行变异 62 mutate_point = np.random.randint(0, DNA_SIZE * 2) # 随机选择变异点 63 child[mutate_point] = np.logical_xor(child[mutate_point], 1) # 反转变异点的基因 64 65# 选择函数，根据适应度选择个体 66def select(pop, fitness): 67 idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=(fitness / fitness.sum())) # 根据适应度比例选择个体 68 return pop[idx] 69 70# 打印信息函数，输出当前种群的状态 71def print_info(pop): 72 fitness = get_fitness(pop) # 计算适应度 73 max_fitness_index = np.argmax(fitness) # 找到最大适应度的索引 74 print(\u0026#34;max_fitness:\u0026#34;, fitness[max_fitness_index]) # 打印最大适应度 75 x, y = translateDNA(pop) # 转换DNA为坐标 76 print(\u0026#34;最优的基因型：\u0026#34;, pop[max_fitness_index]) # 打印最优个体的基因型 77 print(\u0026#34;(x, y):\u0026#34;, (x[max_fitness_index], y[max_fitness_index])) # 打印最优个体的坐标 78 print(F(x[max_fitness_index], y[max_fitness_index])) # 打印最优个体的函数值 79 80# 程序的主执行部分 81if __name__ == \u0026#34;__main__\u0026#34;: 82 fig = plt.figure() # 创建一个新的图形 83 ax = fig.add_axes(Axes3D(fig)) # 添加一个3D坐标轴 84 plt.ion() # 设置绘图模式为交互模式 85 plot_3d(ax) # 绘制3D曲面 86 87 pop = np.random.randint(2, size=(POP_SIZE, DNA_SIZE * 2)) # 初始化种群 88 for _ in range(N_GENERATIONS): # 进行N_GENERATIONS代进化 89 x, y = translateDNA(pop) # 转换DNA为坐标 90 sca = ax.scatter(x, y, get_fitness(pop), c=\u0026#39;black\u0026#39;, marker=\u0026#39;o\u0026#39;) # 在3D图上绘制当前种群 91 plt.show() # 显示图形 92 plt.pause(0.1) # 暂停0.1秒 93 pop = crossover_and_mutation(pop) # 交叉和变异操作 94 fitness = get_fitness(pop) # 计算适应度 95 pop = select(pop, fitness) # 选择操作，生成新的种群 96 97 print_info(pop) # 打印最终的种群信息 98 plt.ioff() # 关闭交互模式 99 plot_3d(ax) # 重新绘制3D曲面 代码解释 这段代码是一个遗传算法（Genetic Algorithm, GA）的实现，用于解决优化问题。遗传算法是一种启发式搜索算法，模仿自然选择的过程来找到问题的近似解。在这个例子中，算法的目标是寻找一个二维点 (x, y)，使得给定的函数 F(x, y) 达到最小值。这个函数是一个典型的测试函数，称为香蕉函数（Banana Function），用于测试优化算法的性能。\n以下是代码的主要组成部分及其功能解释：\n初始化参数：定义了DNA的大小（DNA_SIZE），种群的大小（POP_SIZE），交叉率（CROSSOVER_RATE），变异率（MUTATION_RATE），进化代数（N_GENERATIONS），以及搜索空间的边界（X_BOUND 和 Y_BOUND）。\n目标函数 F(x, y)：这是需要优化的函数，输入是 x 和 y 坐标，输出是一个数值。遗传算法的目标是找到使这个函数值最小的 (x, y) 点。\n绘图函数 plot_3d(ax)：使用 matplotlib 库绘制目标函数的三维图形，帮助我们直观地理解函数形状和搜索空间。\n适应度函数 get_fitness(pop)：计算种群中每个个体的适应度。适应度是根据目标函数值来评估的，这里直接使用了目标函数 F(x, y) 的值。\nDNA 转换函数 translateDNA(pop)：将二进制编码的DNA转换为实数解（x 和 y 坐标）。这是通过将DNA中的每一位乘以2的相应幂次然后求和来实现的。\n交叉和变异函数 crossover_and_mutation(pop)：对种群中的个体执行交叉和变异操作。交叉是遗传算法中的一种操作，它模仿生物遗传中的交叉过程，通过交换父代的基因来产生新的后代。变异是另一种操作，它通过随机改变基因的值来引入种群的多样性。\n选择函数 select(pop, fitness)：根据个体的适应度来选择下一代种群。适应度更高的个体有更大的概率被选中。\n打印信息函数 print_info(pop)：输出当前种群中适应度最高的个体及其对应的 (x, y) 坐标和函数值。\n主程序：初始化种群，然后进行多代进化。每一代都会计算种群的适应度，执行交叉和变异操作，然后选择新的种群。同时，会实时更新并显示当前种群在目标函数上的分布情况。\n这段代码展示了遗传算法的基本流程，包括初始化、适应度计算、选择、交叉、变异和新一代种群的生成。通过多次迭代，算法逐渐找到使目标函数值最小化的解。这种方法在解决复杂的优化问题时非常有用，尤其是当问题的解空间很大或者目标函数难以直接优化时。\n算法应用 若只有选择和交叉，而没有变异，则无法在初始基因组合以外的空间进行搜索，使进化过程在早期就陷入局部解而进入终止过程，从而影响解的质量。为了在尽可能大的空间中获得质量较高的优化解，必须采用变异操作。\n交叉率的取值范围：一般为0.4～0.99，变异率的取值范围：一般为0.0001～0.1\n终止条件 第一种：迭代次数 第二种：当目标函数是方差这一类有最优目标值的问题时，可采用控制偏差的方法实现终止。一旦遗传算法得出的目标函数值（适应度）与实际目标值之差小于允许值后，算法终止。 第三种：检查适应度的变化。在遗传算法后期，一旦最优个体的适应度没有变化或变化很小时，即令计算终止。\n遗传算法的另一个重要参数是每代群体中的个体数。很明显，个体数目越多，搜索范围越广，容易获取全局最优解。然而个体数目太多，每次迭代时间也长。通常，个体数目可取100-1000之间。\n应用领域\n函数优化 函数优化是遗传算法的经典应用领域，也是遗传算法进行性能评价的常用算例。尤其是对非线性、多模型、多目标的函数优化问题，采用其他优化方法较难求解，而遗传算法却可以得到较好的结果。 组合优化。 随着问题的增大，组合优化问题的搜索空间也急剧扩大，采用传统的优化方法很难得到最优解。遗传算法是寻求这种满意解的最佳工具。例如，遗传算法已经在求解旅行商问题、背包问题、装箱问题、图形划分问题等方面得到成功的应用. 生产调度问题 在很多情况下，采用建立数学模型的方法难以对生产调度问题进行精确求解。在现实生产中多采用一些经验进行调度。遗传算法是解决复杂调度问题的有效工具，在单件生产车间调度、流水线生产车间调度、生产规划、任务分配等方面遗传算法都得到了有效的应用。 自动控制。 在自动控制领域中有很多与优化相关的问题需要求解，遗传算法已经在其中得到了初步的应用。例如，利用遗传算法进行控制器参数的优化、基于遗传算法的模糊控制规则的学习、基于遗传算法的参数辨识、基于遗传算法的神经网络结构的优化和权值学习等。 机器人 例如，遗传算法已经在移动机器人路径规划、关节机器人运动轨迹规划、机器人结构优化和行为协调等方面得到研究和应用。 图像处理 遗传算法可用于图像处理过程中的扫描、特征提取、图像分割等的优化计算。目前遗传算法已经在模式识别、图像恢复、图像边缘特征提取等方面得到了应用。 遗传算法的基本特征 智能式搜索 遗传算法的搜索策略，既不是盲目式的乱搜索，也不是穷举式的全面搜索，它是有指导的搜索。指导遗传算法执行搜索的依据是适应度，也就是它的目标函数。利用适应度，使遗传算法逐步逼近目标值。 渐进式优化 遗传算法利用复制、交换、突变等操作，使新一代的结果优越于旧一代，通过不断迭代，逐渐得出最优的结果，它是一种反复迭代的过程。 全局最优解 遗传算法由于采用交换、突变等操作，产生新的个体，扩大了搜索范围，使得搜索得到的优化结果是全局最优解而不是局部最优解。 黑箱式结构 遗传算法根据所解决问题的特性，进行编码和选择适应度。一旦完成字符串和适应度的表达，其余的复制、交换、突变等操作都可按常规手续执行。个体的编码如同输入，适应度如同输出。因此遗传算法从某种意义上讲是一种只考虑输入与输出关系的黑箱问题。 通用性强 传统的优化算法，需要将所解决的问题用数学式子表示，常常要求解该数学函数的一阶导数或二阶导数。采用遗传算法，只用编码及适应度表示问题，并不要求明确的数学方程及导数表达式。因此，遗传算法通用性强，可应用于离散问题及函数关系不明确的复杂问题，有人称遗传算法是一种框架型算法，它只有一些简单的原则要求，在实施过程中可以赋予更多的含义。 并行式算法 遗传算法是从初始群体出发，经过复制、交换、突变等操作，产生一组新的群体。每次迭代计算，都是针对一组个体同时进行，而不是针对某个个体进行。因此，尽管遗传算法是一种搜索算法，但是由于采用这种并行机理，搜索速度很高。这种并行式计算是遗传算法的一个重要特征。 参考资料 https://zhuanlan.zhihu.com/p/378906456\n","date":"2024-04-19T20:25:38+08:00","permalink":"http://localhost:1313/posts/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/","title":"遗传算法的python实现"},{"content":"本篇基于github上的开源项目https://github.com/xyhelper/chatgpt-mirror-server旨在通过简单的操作搭建一个ChatGPT的个人镜像，绕过cloudflare，提升访问速度，且没有烦人的机器人验证步骤，可本地搭建，也可部署在服务器上，通过登录官网账号的方式，非api模式，提高回答准确性。同时，基于共享账号的普遍存在，可以实现成本远低于api模式的GPT4和GPTs使用。\n前置条件 一台至少 2 核 2G 内存的服务器,推荐使用香港、新加坡、日本地区的服务器,可以 兼顾国内访问。(本地搭建的话可忽略) 安装了 docker 和 docker-compose 安装了 git 有官网直登账号(不支持谷歌、微软、苹果等第三方登陆账号) 一个域名（用于反代，可忽略） 准备工作 打开服务器，输入：\n1apt update -y \u0026amp;\u0026amp; apt upgrade -y \u0026amp;\u0026amp; apt install -y vim wget curl #出现报错可能是权限问题，用`sudo su`提权至root用户 自动部署 直接下载执行官方的一键部署脚本\n1curl -sSfL https://raw.githubusercontent.com/xyhelper/chatgpt-mirror-server-deploy/master/quick-install.sh | bash 手动部署 1git clone --depth=1 https://github.com/xyhelper/chatgpt-mirror-server-deploy.git chatgpt-mirror # 克隆项目地址 2cd chatgpt-mirror #进入根目录 3./deploy.sh #启动部署脚本，等待拉取docker镜像 进入管理后台进行基础配置 访问http://服务器ip地址:8200/xyhelper\n默认用户名admin，密码123456 进入后台左边点击工作台-账号管理，添加自己的ChatGPT官网账号勾选启用（plus用户切记勾选plus），再进入用户管理，添加一个用户，过期日期和user-token都可以自定义，保存。复制user-token，返回首页，粘贴。\n一个小细节 如果你是plus用户，或者使用的是共享账号，想把这个镜像站分享给其他人，又想省去每次都输入token的麻烦，不妨自定义ygusertoken，比方说我设置的是1145141919810hhhhaaa，然后把这个链接：http://yourip:8200/login_token?access_token=1145141919810hhhhaaa分享出去，这样就·不用·每次都登录了。\n配置nginx反代 新建nginx配置目录：\n1mkdir -p /home/nginx 2 3touch /home/nginx/nginx.conf 4 5mkdir -p /home/nginx/certs 申请证书\n1curl https://get.acme.sh | sh 2 3~/.acme.sh/acme.sh --register-account -m xxxx@gmail.com #随便一个邮箱就行 4 5 6~/.acme.sh/acme.sh --issue -d yourip.com --standalone # yourip.com改为你的域名 下载证书到本地\n1~/.acme.sh/acme.sh --installcert -d yourip.com --key-file /home/nginx/certs/key.pem --fullchain-file /home/nginx/certs/cert.pem 填写nginx配置文件 cd /home/nginx/ \u0026amp;\u0026amp; vim nginx.conf\n1events { 2 3 worker_connections 1024; 4 5} 6 7 8 9http { 10 11 12 13 client_max_body_size 1000m; 14 15 #上传限制参数1G以内文件可上传 16 17 18 19 server { 20 21 listen 80; 22 23 server_name yourip.com; # 同理，替换为你的域名 24 25 return 301 https://$host$request_uri; 26 27 } 28 29 30 31 server { 32 33 listen 443 ssl http2; 34 35 server_name yourip.com; # 替换域名 36 37 ssl_certificate /etc/nginx/certs/cert.pem; 38 39 ssl_certificate_key /etc/nginx/certs/key.pem; 40 41 location / { 42 43 proxy_pass http://127.0.0.1:8200; 44 45 proxy_set_header Host $host; 46 47 proxy_set_header X-Real-IP $remote_addr; 48 49 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 50 51 } 52 53 } 54 55} 拉取部署nginx容器\n1docker run -d --name nginx -p 80:80 -p 443:443 -v /home/nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/nginx/certs:/etc/nginx/certs -v /home/nginx/html:/usr/share/nginx/html nginx:latest 之后就可以用域名访问啦！\n","date":"2024-04-14T17:30:22+08:00","permalink":"http://localhost:1313/posts/3%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt%E9%95%9C%E5%83%8F%E7%AB%99%E9%9D%9Eapi%E6%94%AF%E6%8C%81%E5%AE%98%E7%BD%91%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95/","title":"3分钟搭建一个ChatGPT镜像站，非api，支持官网账号登录"},{"content":"成品展示 原理 通过alist挂载网盘，然后用RaiDrive的webdav功能将网盘内容映射到本地，可以直接对网盘内容进行增删改查，实现近似本地词牌的功能。\nalist下载安装 alist官方下载 GitHub访问较慢的也可以从该链接下载: alist下载\n将下载的压缩包解压到指定的目录下 此目录下运行cmd，输入 .\\alist.exe server开始安装程序 当看到输出start server@0.0.0.0:5244且后续无报错时，说明安装完成。初始会指定alist用户名为admin，并随机一个密码，该密码会在安装时展示，也可以使用.\\alist.exe admin查询 安装成功后，浏览器打开 127.0.0.1:5244即可访问alist管理界面。输入刚刚的用户名和密码，点击管理，可以进入管理界面修改用户名和密码。 关闭该进程可以在cmd界面按下Crtl+C，之后重新启动以及更改密码可以在根目录使用如下命令 1alist start 2alist admin set your_passwd #your_passwd改为你要更改的密码 alist挂载网盘 点击管理界面的存储-添加-驱动，即可添加指定网盘，目前已支持几十种 这部分内容在alist的官方文档里已经足够详细，这里以阿里云盘为例，其他的不再赘述，附上官方文档链接，供大家参考 alist官方文档/添加存储\n驱动 选择阿里云盘open\n挂载路径 可自定义，比方说/aliyun\n获取刷新令牌 刷新令牌 根据文档里的说明进行获取，访问下面地址，按下面图片操作\n地址 复制 token，回到到刷新令牌处粘贴，点击保存\n配置alist开机自启 在alist根目录中新建文版文档，填入以下内容:\n1Set ws = CreateObject(\u0026#34;Wscript.Shell\u0026#34;) 2ws.run \u0026#34;alist.exe server\u0026#34;,vbhide 保存，更改后缀名为vbs，右键-创建快捷方式，将快捷方式移动到开机自启的目录C：\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp下。该目录可以使用Crtl+R，输入shell:Common Startup回车后打开。\nraidrive安装与配置 直接访问官网下载对应版本， raidrive官网下载\n之后一步步安装即可\n网盘映射 raidrive界面-添加-NAS-WebDAV\n虚拟驱动器 第一行选择喜欢的盘符字母，默认为Z\n地址 取消勾选 ，第一行第一格IP输入 127.0.0.1(或localhost) 第二格端口输入 5244\n第二行输入/dav即可，这样alist挂载的所有网盘都会被映射到本地，也可以跟上特定后缀，比方说你的阿里云盘被挂载在alist的/aliyun目录下，那第二行就可以改成/dav/aliyun，这样，就只有阿里云盘被映射到本地了\n第三行输入账户密码，点击连接即可。 最后如果是这样的就代表没问题了，可以打开我的电脑查看是否有一个绿色的webdav出现。 END ","date":"2024-04-10T22:59:40Z","permalink":"http://localhost:1313/posts/%E7%94%A8alist-raidrive%E5%B0%86%E7%BD%91%E7%9B%98%E7%A9%BA%E9%97%B4%E6%8C%82%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0/","title":"用alist+raidrive将网盘空间挂载到本地"},{"content":"成品展示 准备工作 一台vps（若只是个人使用的话也可以是任意一台手机或电脑） 安装docker和docker-compose 一个域名（同第一条，仅个人使用可忽略，但你也不想每次登录都先输一大串IP地址吧） vps的话，国内推荐阿里云和腾讯云，都有学生优惠，能白嫖几个月，其他诸如雨云等没试过，不做推荐。国外有微软的azure，学生免费一年，亚马逊（容易被封且需要绑信用卡，有被反撸的可能），还有谷歌云，但也是需要信用卡，有被反撸的风险，digitalorcean通过GitHub学生包可以白嫖200美元额度，还有老牌付费vps厂家如vultr，新晋便宜vps商nackhard等，就不一一列举了。\n域名注册国内可以用阿里腾讯，国外namesilo,name.com,cloudflare等都还不错，便宜的域名一年十块左右就能搞定了（tips：纯数字域名，尤其是6位及以上的，一般会比字母域名便宜很多）\n新机到手，更新环境 apt update -y \u0026amp;\u0026amp; apt upgrade -y \u0026amp;\u0026amp; apt install -y curl wget sudo socat vim\n安装docker和docker-compose 1curl -fsSL https://get.docker.com | sh # 下载最新的官方脚本 2 3curl -L \u0026#34;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 4 5chmod +x /usr/local/bin/docker-compose #给予对应目录权限 Cloudreve和离线下载构建 创建目录，创建文件 1cd /home/ \u0026amp;\u0026amp; mkdir cloud \u0026amp;\u0026amp; cd cloud \u0026amp;\u0026amp; mkdir -vp cloudreve/{uploads,avatar} \u0026amp;\u0026amp; touch cloudreve/conf.ini \u0026amp;\u0026amp; touch cloudreve/cloudreve.db \u0026amp;\u0026amp; mkdir -p aria2/config \u0026amp;\u0026amp; mkdir -p data/aria2 \u0026amp;\u0026amp; chmod -R 777 data/aria2 2# cloud即根目录，aira2为离线下载工具，可按需求酌情考虑是否创建 创建compose配置文件 cd /home/cloud/ \u0026amp;\u0026amp; vim docker-compose.yml\n在docker-compose中配置Cloudreve代码 1version: \u0026#34;3.8\u0026#34; 2 3services: 4 5 cloudreve: 6 7 container_name: cloudreve 8 9 image: cloudreve/cloudreve:latest 10 11 restart: unless-stopped 12 13 ports: 14 15 - \u0026#34;5212:5212\u0026#34; 16 17 volumes: 18 19 - temp_data:/data 20 21 - ./cloudreve/uploads:/cloudreve/uploads 22 23 - ./cloudreve/conf.ini:/cloudreve/conf.ini 24 25 - ./cloudreve/cloudreve.db:/cloudreve/cloudreve.db 26 27 - ./cloudreve/avatar:/cloudreve/avatar 28 29 depends_on: 30 31 - aria2 32 33 aria2: 34 35 container_name: aria2 36 37 image: p3terx/aria2-pro 38 39 restart: unless-stopped 40 41 environment: 42 43 - RPC_SECRET= DOWNLOAD 44 45 - RPC_PORT=6800 46 47 volumes: 48 49 - ./aria2/config:/config 50 51 - temp_data:/data 52 53volumes: 54 55 temp_data: 56 57 driver: local 58 59 driver_opts: 60 61 type: none 62 63 device: $PWD/data 64 65 o: bind 运行 cd /home/cloud \u0026amp;\u0026amp; docker-compose up -d\n容器正常启动后就可以用服务器IP+端口号5212进入网盘设置界面了\n查询初始登录账号密码 docker-compose logs cloudreve\n一般初始账号为admin@cloudreve.org ，密码为admin\n基础配置 点击头像-管理面板，找到用户组/用户,点右边的编辑，可以进行一些基础的配置，包括但不限于分配空间，更改账号密码等。 添加存储策略，有详细的文档，这里就不赘述了，个人推荐onedrive，主要是免费。当然如果你的vps空间足够或者不打算存太多东西的话，默认的本机存储也可以。\n离线下载节点配置 1RPC 服务器地址 =\u0026gt; http://aria2:6800 2RPC 授权令牌 =\u0026gt; DOWNLOAD 3节点下载目录 =\u0026gt; /data NGINX反向代理到域名 配置dns解析：\n创建nginx目录结构 1mkdir -p /home/nginx 2 3touch /home/nginx/nginx.conf 4 5mkdir -p /home/nginx/certs 申请证书 1curl https://get.acme.sh | sh 2 3~/.acme.sh/acme.sh --register-account -m xxxx@gmail.com #随便一个邮箱就行 4 5 6~/.acme.sh/acme.sh --issue -d yourip.com --standalone # yourip.com改为你的域名 下载证书到本地 1~/.acme.sh/acme.sh --installcert -d yourip.com --key-file /home/nginx/certs/key.pem --fullchain-file /home/nginx/certs/cert.pem 进入目录配置nginx cd /home/nginx/ \u0026amp;\u0026amp; nano nginx.conf\n反向代理配置，代理指定IP加端口 1events { 2 3 worker_connections 1024; 4 5} 6 7 8 9http { 10 11 12 13 client_max_body_size 1000m; 14 15 #上传限制参数1G以内文件可上传 16 17 18 19 server { 20 21 listen 80; 22 23 server_name yourip.com; # 同理，替换为你的域名 24 25 return 301 https://$host$request_uri; 26 27 } 28 29 30 31 server { 32 33 listen 443 ssl http2; 34 35 server_name yourip.com; # 替换域名 36 37 ssl_certificate /etc/nginx/certs/cert.pem; 38 39 ssl_certificate_key /etc/nginx/certs/key.pem; 40 41 location / { 42 43 proxy_pass http://127.0.0.1:5212; 44 45 proxy_set_header Host $host; 46 47 proxy_set_header X-Real-IP $remote_addr; 48 49 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 50 51 } 52 53 } 54 55} 下载部署容器 1docker run -d --name nginx -p 80:80 -p 443:443 -v /home/nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/nginx/certs:/etc/nginx/certs -v /home/nginx/html:/usr/share/nginx/html nginx:latest 查看运行状态 docker ps -a 可以看到容器都是正常运行的\n之后就可以用域名访问你的cloudreve网盘了！\n","date":"2024-04-06T18:55:04Z","permalink":"http://localhost:1313/posts/%E7%94%A8docker%E6%90%AD%E5%BB%BAcloudreve%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98%E7%B3%BB%E7%BB%9F/","title":"用docker搭建cloudreve个人网盘系统"},{"content":"成品展示 使用工具： git github hexo vscode( 任意具备markdown编辑能力的工具均可) git安装 git官网下载 选择电脑对应版本安装即可（一般为64位）\nnode、npm安装 node.js官网\n当然，你也可以直接用winget安装，省的去官网下载 关于winget的使用，可以看完另一篇博客：winget的基础配置与使用\n1winget install Git.Git 2winget install OpenJS.NodeJS.LTS hexo创建个人博客 安装hexo 1.在任意目录下新建hexo文件夹 打开该文件夹，空白处单击鼠标右键:Git Bash Here 在打开的git bash 窗口中依次输入以下命令： 1npm install hexo-cli -g 2hexo init blog 3cd blog 4npm install 5hexo server 全部执行完成后，hexo目录下会出现一个新的blog文件夹，里面就是存放博客的地方\n然后输入这两条命令 1hexo g 2hexo s 完成后若显示诸如http://localhost:4000的内容，则说明配置成功。 打开浏览器，地址栏输入上面的地址，即可进入初始博客的预览界面，它长这样：\n为什么说是预览界面呢，因为她现在仅仅只是部署在你电脑本地的一个离线版本，只能在你自己的电脑上看见，想要正式发布公开，你需要一台拥有公网IP的服务器，但还有一个更简单的方法，即借助GitHub page的ssh功能实现对外访问。\nGitHub创建仓库 首先创建一个GitHub账号，然后在个人主页新建仓库，仓库名为username.github.io,username即你的用户名。 回到gitbash窗口，按Ctrl+C 关闭4000端口的预览，输入以下命令： 1git config --global user.name \u0026#34;yourname\u0026#34; # yourname改为GitHub用户名 2git config --global user.email \u0026#34;youremail\u0026#34; #youremail改为注册GitHub所用的邮箱 3ssh-keygen -t rsa -C \u0026#34;youremail\u0026#34; #创建ssh连接 之后会提示你已经完成ssh创建，接着找到该路径下的这两个文件： 把id_rsa.pub里的内容复制下来，打开GitHub的设置界面（点击头像-setting），找到SSH and GPG keys,x新建一个ssh key，粘贴进key中，title随便填一个就行，保存。\nhexo部署到GitHub 在blog文件夹下找到_config.yml,这是博客的配置文件,在这里可以修改博客的一些基本信息，打开它，找到下面这段内容,在最底下： 1# Deployment 2## Docs: https://hexo.io/docs/one-command-deployment 3deploy: 4 type: \u0026#39;\u0026#39; 修改deploy部分：\n1deploy: 2 type: git 3 repo: https://github.com/username/username.github.io.git #username改为用户名 4 branch: master 另外找到第十六行，修改url为 https://username.github.io\n完成后保存文件并退出，在gitbash中输入：npm install hexo-deployer-git --save,安装git部署工具。\n最后输入以下三行命令：\n1hexo clean #清除缓存 2hexo g #生产静态文章（博客） 3hexo d #部署 当然，如果仅是在本地查看效果，第三行命令也可以换成hexo s 部署过程中可能会出现warning警告，但不要紧，只要最后呈现这样的内容，就表示成功了： 之后，你就可以 username.github.io访问到你的博客了，且可以被任何人访问到。 常用命令 在根目录打开gitbash：\n1hexo new \u0026#34;博客名称\u0026#34; #新建博客 2hexo clean #清除缓存和静态文件 3hexo g #生产静态文件 4hexo s #生成离线版本 5hexo d #部署 添加插件 主题 我使用的是next，一款简洁美观的主题，功能强大，可拓展性强，在gitbash中下载： git clone https://github.com/next-theme/hexo-theme-next themes/next 下载完成后，在blog下找到themes文件夹-next,打开主题的_config.yml文件，找到如下部分，大概在100行左右：\n1# Schemes 2#scheme: Muse 3#scheme: Mist 4#scheme: Pisces 5#scheme: Gemini 这代表了四种不同风格的next主题，任选一个取消注释即可。 之后回到根目录的_config.yml文件，找到theme选项，输入next 博客基本信息 在blog下找到_config.yml并打开，配置站点信息 注意，语言要改成中文：zh-CN,其他的可以按个人喜好更改。\nEND ","date":"2024-03-28T21:17:07+08:00","permalink":"http://localhost:1313/posts/%E5%9F%BA%E4%BA%8Ehexo%E5%92%8Cgithubpage%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"基于hexo和GitHub page搭建个人博客"},{"content":" 常用快捷键 注释 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/\n取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)\n多行注释：[alt+shift+A]\n多行注释：/**\n移动行 alt+up/down\n显示/隐藏左侧目录栏 Ctrl+b\n复制当前行 shift + alt +up/down\n删除当前行 shift + ctrl + k\n控制台终端显示与隐藏 Ctrl + ~\n查找文件/安装vs code 插件地址 Ctrl + p\n代码格式化 shift + alt + f\n新建窗口 ctrl + shift + n\n行增加缩进 Ctrl + [\n行减少缩进 Ctrl + ]\n裁剪尾随空格 Ctrl + shift + x\n字体放大(缩小) Ctrl + (或-)\n拆分编辑器 Ctrl +1/2/3\n切换窗口 ctrl + shift + left/right\n关闭编辑器窗口 Ctrl + w\n关闭所有窗口 Ctrl + k + w\n切换全屏 f11\n自动换行 alt + z\n显示Git Ctrl + shift + g\n全局查找文件 Ctrl + shift + f\n显示相关插件的命令(如：git log) Ctrl + shift + p\n选中文字 shift + left / right / up / down\n折叠代码 ctrl + k + 0-9 (0是完全折叠)\n展开代码 ctrl + k + j (完全展开代码)\n删除行 Ctrl + shift + k\n快速切换主题 Ctrl + k/Ctrl + t\n快速回到顶部/底部 Ctrl + home/end\n格式化选定代码 Ctrl + k/f\n选中代码 shift + 鼠标左键\n多行同时添加内容（光标） ctrl + alt + up/down\n全局替换 ctrl + shift + h\n当前文件替换 Ctrl + h\n打开最近打开的文件 Ctrl + r\n打开新的命令窗 ctrl + shift + c\n常用插件 1、Auto Rename Tag 修改html标签，自动帮你完成尾部闭合标签的同步修改，和webstorm一样。\n2、Auto Close Tag 自动闭合HTML标签\n4、Beautiful 格式化代码的工具\n5、Dash Dash 是MacOS的API文档浏览器和代码段管理器\n6、Ejs Snippets ejs 代码提示\n7、ESLint 检查javascript语法错误与提示\n8、File Navigator 快速查找文件\n9、Git History(git log) 查看git log\n10、Gulp Snippets 写gulp时用到，gulp语法提示。\n11、HTML CSS Support 在HTML标签上写class智能提示当前项目所支持的样式\n12、HTML Snippets 超级好用且初级的H5代码片段以及提示\n13、Debug for Chrome 让vs code映射chrome的debug功能，静态页面都可以用vscode来打断点调试、配饰稍微复杂一点\n14、Document this Js的注释模板\n15、jQuery Code Snippets jquery提示工具\n16、Html2jade html模板转pug模板\n17、JS-CSS-HTML Formatter 格式化\n18、Npm intellisense require 时的包提示工具\n19、Open in browser 打开默认浏览器\n20、One Dark Theme 一个vs code的主题\n21、Path Intellisense 自动路径补全、默认不带这个功能\n22、Project Manager 多个项目之间快速切换的工具\n23、Typings auto installer 安装vscode 的代码提示依赖库，基于typtings的\n24、View In Browser 默认浏览器查看HTML文件（快捷键Ctrl+F1可以修改）\n25、Vscode-icons 让vscode资源目录加上图标、必备\n26、VueHelper Vue2代码段（包括Vue2 api、vue-router2、vuex2）\n27、Vue 2 Snippets vue必备vue代码提示\n28、Vue-color vue语法高亮主题\n29、Auto-Open Markdown Preview markdown文件自动开启预览\n","date":"2024-03-26T17:12:02Z","permalink":"http://localhost:1313/posts/vscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%8F%92%E4%BB%B6/","title":"VSCode常用快捷键及插件"},{"content":"1.什么是winget 微软公司在 2020 年 5 月 Microsoft Build 开发者大会上发布了用于 Windows 系统的官方支持的软件包管理器 —— Windows 软件包管理器（Windows Package Manager），也就是 WinGet 软件包管理器。经过 3 年的发展，越来越多的软件厂商在这个平台上发布自家软件。WinGet 除了支持 exe、msi 等传统的 Win32 安装包格式外，还支持用于新版 Windows 的 msix/msixbundle 格式所打包的软件。\nWindows软件包管理工具\n2.获取winget 首先确认系统是否满足需求：WinGet 只可以运行在 Windows10 高于 1709 (Build 16299) 的版本和 Windows11 上。\n在安装 WinGet 之前，建议使用微软新推出的终端模拟器 Windows Terminal 代替传统的conhost.exe。\n2.1 Windows10/11 非 LTS 版本（家庭版、教育版、专业版、专业工作站版、企业版） Windows Terminal 和 WinGet 都可以通过系统预装的 Microsoft Store 商店搜索安装，也可以转到下面的网页调用 Microsoft Store 安装，也可以去微软托管在 GitHub 的发布页下载安装包到本地安装（较新版本的 Windows11 已经预装，如已预装请略过此章节）\nWindows Terminal Windows Terminal\nWinget Winget\n2.2 设置 Windows Terminal 为系统默认终端模拟器 较新版本的 Windows11 已经默认 Windows Terminal 为系统终端模拟器，如已配置好请略过此章节。\n从命令行窗口标题栏右键菜单进入默认设置,在【终端】选项卡下更改“默认终端应用程序”为“Windows 终端”，确认退出.\n3. 使用 WinGet 管理软件 常用命令 查看版本、信息 1winget -v(winget --version) #显示winget版本 2winget info #显示常规信息 替换源： 1winget source remove winget 2winget source add winget https://mirrors.ustc.edu.cn/winget-source 搜索软件包 winget search [包名] 以7zip为例 查看软件包 winget show --id 7zip.7zip 安装软件包 winget install --id 7zip.7zip\n自定义安装 winget install --id 7zip.7zip -i\n-指定位置安装 winget install -l,--location [指定路径(如支持)]\n更新软件包 winget upgrade --id 7zip.7zip\n卸载软件包 winget uninstall --id 7zip.7zip\n显示已安装的软件包 winget list\n其他命令 winget search --id [包名] #按id筛选结果\nwinget search --name [包名] #按名称筛选\nwinget search --tag [包名] #按标签筛选\nwinget search -s,--source [包名] #指定源查找\nwinget search -e,--exact [包名] #精确匹配查找\nwinget search --version [包名] #显示软件包可用版本\nwinget install --id/--name/--tag/-e,--exact/--version [包名] #与search类似\nwinget install --ignore-security-hash [包名] #忽略安装程序哈希检查失败\n进阶\u0026mdash;使用PowerShell 脚本从网络批量下载来自 WinGet 的软件包 1# Requires -Version 7.0 2 3#更改字符集为UTF-8 4#[System.Console]::OutputEncoding=[System.Text.Encoding]::GetEncoding(65001) 5 6# 更新源 7# winget source reset winget 8# winget source add winget https://mirrors.ustc.edu.cn/winget-source/ 9 10Clear-Host 11 12# 写入安装脚本 13$Script:PackageCount = 0 14$Script:PackageLocalPath = \u0026#34;PackageInstallers\u0026#34; 15$Script:PackageList = \u0026#34;PackageInstallers.log\u0026#34; 16$Script:PackageScriptIWR = \u0026#34;Get-PackageInstallersIWR.ps1\u0026#34; 17$Script:PackageScriptSBT = \u0026#34;Get-PackageInstallersSBT.ps1\u0026#34; 18$Script:PackageScriptWCD = \u0026#34;Get-PackageInstallersWCD.ps1\u0026#34; 19$Script:PackageLogIWR = [System.String]::Concat($Script:PackageLocalPath, \u0026#34;\\PackageInstallersIWR.log\u0026#34;) 20$Script:PackageLogSBT = [System.String]::Concat($Script:PackageLocalPath, \u0026#34;\\PackageInstallersSBT.log\u0026#34;) 21$Script:PackageLogWCD = [System.String]::Concat($Script:PackageLocalPath, \u0026#34;\\PackageInstallersWCD.log\u0026#34;) 22 23New-Item -Name $Script:PackageLocalPath -ItemType Directory -Force | Out-Null 24Remove-Item $Script:PackageLocalPath\\* -Recurse -Force | Out-Null 25 26Write-Output $null | Out-File $Script:PackageList 27Write-Output $null | Out-File $Script:PackageScriptIWR 28Write-Output $null | Out-File $Script:PackageScriptSBT 29Write-Output $null | Out-File $Script:PackageScriptWCD 30 31[System.String]::Concat(\u0026#34;# Updated @ \u0026#34;, (Get-Date -Format \u0026#34;yyyy.MM.dd-HH:mm:ss\u0026#34;)) | Tee-Object $Script:PackageScriptIWR -Append | Tee-Object $Script:PackageScriptSBT -Append | Out-File $Script:PackageScriptWCD -Append 32Write-Output \u0026#34;# Requires -Version 7.0\u0026#34; | Tee-Object $Script:PackageScriptIWR -Append | Tee-Object $Script:PackageScriptSBT -Append | Out-File $Script:PackageScriptWCD -Append 33Write-Output \u0026#34;`$Script:PackageLocalCount = 0\u0026#34; | Tee-Object $Script:PackageScriptIWR -Append | Tee-Object $Script:PackageScriptSBT -Append | Out-File $Script:PackageScriptWCD -Append 34Write-Output \u0026#34;Clear-Host\u0026#34; | Tee-Object $Script:PackageScriptIWR -Append | Tee-Object $Script:PackageScriptSBT -Append | Out-File $Script:PackageScriptWCD -Append 35Write-Output \u0026#34;New-Item -Name `\u0026#34;$Script:PackageLocalPath`\u0026#34; -ItemType Directory -Force | Out-Null\u0026#34; | Tee-Object $Script:PackageScriptIWR -Append | Tee-Object $Script:PackageScriptSBT -Append | Out-File $Script:PackageScriptWCD -Append 36Write-Output \u0026#34;Remove-Item `\u0026#34;$Script:PackageLocalPath\\*`\u0026#34; -Recurse -Force | Out-Null\u0026#34; | Tee-Object $Script:PackageScriptIWR -Append | Tee-Object $Script:PackageScriptSBT -Append | Out-File $Script:PackageScriptWCD -Append 37Write-Output \u0026#34;Write-Output `$null | Out-File `\u0026#34;$Script:PackageLogIWR`\u0026#34;\u0026#34; | Out-File $Script:PackageScriptIWR -Append 38Write-Output \u0026#34;Write-Output `$null | Out-File `\u0026#34;$Script:PackageLogSBT`\u0026#34;\u0026#34; | Out-File $Script:PackageScriptSBT -Append 39Write-Output \u0026#34;Write-Output `$null | Out-File `\u0026#34;$Script:PackageLogWCD`\u0026#34;\u0026#34; | Out-File $Script:PackageScriptWCD -Append 40 41# 安装脚本函数 42function Get-WinGetPackageURL { 43 param($ID, $Name, $Type, $Class) 44 45 $Private:PackageWinGetID = $ID 46 $Private:PackageFilename = $Name 47 $Private:PackageFiletype = $Type 48 $Private:PackageClassification = $Class 49 $Private:PackageLocalClassifiedPath = [System.String]::Concat($Script:PackageLocalPath, \u0026#34;\\\u0026#34;, $Private:PackageClassification) 50 51 $Private:FindURL = \u0026#34;安装程序 URL：\u0026#34; 52 $Private:FindVER = \u0026#34;版本:\u0026#34; 53 54 # 获取软件包版本和下载地址 55 try { 56 # System Installer 57 $Private:PackageURL = [System.String]::Concat((winget show --scope machine -id $Private:PackageWinGetID | Select-String $Private:FindURL)).Replace($Private:FindURL, \u0026#34;\u0026#34;).Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) 58 $Private:PackageVersion = [System.String]::Concat((winget show --scope machine -id $Private:PackageWinGetID | Select-String $Private:FindVER)).Replace($Private:FindVER, \u0026#34;\u0026#34;).Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) 59 } 60 catch [ArgumentNullException] { 61 # User Installer 62 $Private:PackageURL = [System.String]::Concat((winget show --id $Private:PackageWinGetID | Select-String $Private:FindURL)).Replace($Private:FindURL, \u0026#34;\u0026#34;).Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) 63 $Private:PackageVersion = [System.String]::Concat((winget show --id $Private:PackageWinGetID | Select-String $Private:FindVER)).Replace($Private:FindVER, \u0026#34;\u0026#34;).Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) 64 } 65 66 $Script:PackageCount++ 67 $Private:PackageLocalFile = [System.String]::Concat($Private:PackageLocalClassifiedPath, \u0026#34;\\\u0026#34;, $Private:PackageFilename, \u0026#34;_\u0026#34;, $Private:PackageVersion, \u0026#34;.\u0026#34;, $Private:PackageFiletype) 68 $Private:PackageUpdateTime = Get-Date -Format \u0026#34;yyyy.MM.dd-HH:mm:ss\u0026#34; 69 70 $Private:PackageCommandPath = \u0026#34;New-Item -Name `\u0026#34;$Private:PackageLocalClassifiedPath`\u0026#34; -ItemType Directory -Force | Out-Null\u0026#34; 71 $Private:PackageCommandItem = \u0026#34;New-Item -Name `\u0026#34;$Private:PackageLocalFile`\u0026#34; -ItemType File -Force | Out-Null\u0026#34; 72 $Private:PackageCommandDNS = \u0026#34;ipconfig.exe /flushdns | Out-Null\u0026#34; 73 $Private:PackageCommandIWR = \u0026#34;Invoke-WebRequest -Uri `\u0026#34;$Private:PackageURL`\u0026#34; -OutFile `\u0026#34;$Private:PackageLocalFile`\u0026#34;\u0026#34; 74 $Private:PackageCommandSBT = \u0026#34;Start-BitsTransfer -Source `\u0026#34;$Private:PackageURL`\u0026#34; -Destination `\u0026#34;$Private:PackageLocalFile`\u0026#34;\u0026#34; 75 $Private:PackageCommandWCD = \u0026#34;`$PackageWebClient = New-Object System.Net.WebClient; `$PackageWebClient.DownloadFile(`\u0026#34;$Private:PackageURL`\u0026#34;, `\u0026#34;$Private:PackageLocalFile`\u0026#34;)\u0026#34; 76 $Private:PackageCommandLog = \u0026#34;Start-Sleep -Seconds 3; [System.Console]::Out.Flush(); [System.String]::Concat(`\u0026#34;┏━ `\u0026#34;, (Get-Date -Format `\u0026#34;yyyy.MM.dd-HH:mm:ss`\u0026#34;), `\u0026#34; @ $Private:PackageWinGetID`\u0026#34;, `\u0026#34; [$Private:PackageVersion]``n`\u0026#34;, `\u0026#34;┣━ ```\u0026#34;$Private:PackageURL```\u0026#34;``n`\u0026#34;, `\u0026#34;┗━ ```\u0026#34;$Private:PackageLocalFile```\u0026#34;``n`\u0026#34;) | Write-Output\u0026#34; 77 78 Write-Output \u0026#34;┏━ $Private:PackageUpdateTime @ $Private:PackageWinGetID [$Private:PackageVersion]`n┣━ `\u0026#34;$Private:PackageURL`\u0026#34;`n┗━ `\u0026#34;$Private:PackageLocalFile`\u0026#34;`n\u0026#34; | Tee-Object $Script:PackageList -Append 79 Write-Output \u0026#34;$Private:PackageCommandPath; $Private:PackageCommandItem; $Private:PackageCommandDNS; $Private:PackageCommandIWR; if (`$?) { `$Script:PackageLocalCount++; $Private:PackageCommandLog | Tee-Object `\u0026#34;$Script:PackageLogIWR`\u0026#34; -Append; }\u0026#34; | Out-File $Script:PackageScriptIWR -Append 80 Write-Output \u0026#34;$Private:PackageCommandPath; $Private:PackageCommandItem; $Private:PackageCommandDNS; $Private:PackageCommandSBT; if (`$?) { `$Script:PackageLocalCount++; $Private:PackageCommandLog | Tee-Object `\u0026#34;$Script:PackageLogSBT`\u0026#34; -Append; }\u0026#34; | Out-File $Script:PackageScriptSBT -Append 81 Write-Output \u0026#34;$Private:PackageCommandPath; $Private:PackageCommandItem; $Private:PackageCommandDNS; $Private:PackageCommandWCD; if (`$?) { `$Script:PackageLocalCount++; $Private:PackageCommandLog | Tee-Object `\u0026#34;$Script:PackageLogWCD`\u0026#34; -Append; }\u0026#34; | Out-File $Script:PackageScriptWCD -Append 82 83 New-Item -Name $Private:PackageLocalClassifiedPath -ItemType Directory -Force | Out-Null 84 New-Item -Name $Private:PackageLocalFile -ItemType File -Force | Out-Null 85} 86 87ipconfig /flushdns | Out-Null 88 89# Components 90Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2005.x86\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2005_32bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 91Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2005.x64\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2005_64bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 92Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2008.x86\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2008_32bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 93Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2008.x64\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2008_64bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 94Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2010.x86\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2010_32bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 95Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2010.x64\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2010_64bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 96Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2012.x86\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2012_32bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 97Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2012.x64\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2012_64bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 98Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2013.x86\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2013_32bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 99Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2013.x64\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2013_64bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 100Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2015+.x86\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2015_32bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 101Get-WinGetPackageURL -ID \u0026#34;Microsoft.VCRedist.2015+.x64\u0026#34; -Name \u0026#34;Microsoft_Visual_C++_Redistributable_2015_64bit\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 102Get-WinGetPackageURL -ID \u0026#34;Microsoft.PowerToys\u0026#34; -Name \u0026#34;Microsoft_PowerToys\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 103Get-WinGetPackageURL -ID \u0026#34;EclipseAdoptium.Temurin.8.JDK\u0026#34; -Name \u0026#34;EclipseAdoptium_Temurin_JDK_8_Releases\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Components\u0026#34; 104Get-WinGetPackageURL -ID \u0026#34;EclipseAdoptium.Temurin.11.JDK\u0026#34; -Name \u0026#34;EclipseAdoptium_Temurin_JDK_11_Releases\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Components\u0026#34; 105Get-WinGetPackageURL -ID \u0026#34;EclipseAdoptium.Temurin.17.JDK\u0026#34; -Name \u0026#34;EclipseAdoptium_Temurin_JDK_17_Releases\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Components\u0026#34; 106Get-WinGetPackageURL -ID \u0026#34;Python.Python.2\u0026#34; -Name \u0026#34;Python_2_Dev\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Components\u0026#34; 107Get-WinGetPackageURL -ID \u0026#34;Python.Python.3.8\u0026#34; -Name \u0026#34;Python_3.8_Dev\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 108Get-WinGetPackageURL -ID \u0026#34;Python.Python.3.11\u0026#34; -Name \u0026#34;Python_3.11_Dev\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Components\u0026#34; 109 110# Applications 111Get-WinGetPackageURL -ID \u0026#34;7zip.7zip\u0026#34; -Name \u0026#34;7_Zip\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 112Get-WinGetPackageURL -ID \u0026#34;Anaconda.Anaconda3\u0026#34; -Name \u0026#34;Anaconda3\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 113Get-WinGetPackageURL -ID \u0026#34;Apple.iTunes\u0026#34; -Name \u0026#34;iTunes\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 114Get-WinGetPackageURL -ID \u0026#34;Audacity.Audacity\u0026#34; -Name \u0026#34;Audacity\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 115Get-WinGetPackageURL -ID \u0026#34;Bandisoft.Bandizip\u0026#34; -Name \u0026#34;Bandizip\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 116Get-WinGetPackageURL -ID \u0026#34;Bandisoft.Honeyview\u0026#34; -Name \u0026#34;Honeyview\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 117Get-WinGetPackageURL -ID \u0026#34;Bitvise.SSH.Server\u0026#34; -Name \u0026#34;Bitvise_SSH_Server\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 118Get-WinGetPackageURL -ID \u0026#34;BlenderFoundation.Blender\u0026#34; -Name \u0026#34;Blender\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 119Get-WinGetPackageURL -ID \u0026#34;Codeblocks.Codeblocks\u0026#34; -Name \u0026#34;Codeblocks\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 120Get-WinGetPackageURL -ID \u0026#34;darktable.darktable\u0026#34; -Name \u0026#34;darktable\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 121Get-WinGetPackageURL -ID \u0026#34;den4b.Hasher\u0026#34; -Name \u0026#34;Hasher\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 122Get-WinGetPackageURL -ID \u0026#34;den4b.ReNamer\u0026#34; -Name \u0026#34;ReNamer\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 123Get-WinGetPackageURL -ID \u0026#34;DEVCOM.JetBrainsMonoNerdFont\u0026#34; -Name \u0026#34;Nerd_Fonts\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 124Get-WinGetPackageURL -ID \u0026#34;Geany.Geany\u0026#34; -Name \u0026#34;Geany\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 125Get-WinGetPackageURL -ID \u0026#34;GeekUninstaller.GeekUninstaller\u0026#34; -Name \u0026#34;Geek_Uninstaller\u0026#34; -Type \u0026#34;zip\u0026#34; -Class \u0026#34;Applications\u0026#34; 126Get-WinGetPackageURL -ID \u0026#34;GIMP.GIMP\u0026#34; -Name \u0026#34;GIMP\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 127Get-WinGetPackageURL -ID \u0026#34;Git.Git\u0026#34; -Name \u0026#34;Git\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 128Get-WinGetPackageURL -ID \u0026#34;GitHub.Atom\u0026#34; -Name \u0026#34;Atom\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 129Get-WinGetPackageURL -ID \u0026#34;GitHub.GitHubDesktop\u0026#34; -Name \u0026#34;GitHubDesktop\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 130Get-WinGetPackageURL -ID \u0026#34;GNU.Octave\u0026#34; -Name \u0026#34;Octave\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 131Get-WinGetPackageURL -ID \u0026#34;gnuplot.gnuplot\u0026#34; -Name \u0026#34;gnuplot\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 132Get-WinGetPackageURL -ID \u0026#34;Google.Chrome\u0026#34; -Name \u0026#34;Google_Chrome\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 133Get-WinGetPackageURL -ID \u0026#34;HandBrake.HandBrake\u0026#34; -Name \u0026#34;HandBrake\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 134Get-WinGetPackageURL -ID \u0026#34;Harmonoid.Harmonoid\u0026#34; -Name \u0026#34;Harmonoid\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 135Get-WinGetPackageURL -ID \u0026#34;Henry++.MemReduct\u0026#34; -Name \u0026#34;MemReduct\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 136Get-WinGetPackageURL -ID \u0026#34;JanDeDobbeleer.OhMyPosh\u0026#34; -Name \u0026#34;Oh_My_Posh\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 137Get-WinGetPackageURL -ID \u0026#34;KDE.Kate\u0026#34; -Name \u0026#34;Kate\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 138Get-WinGetPackageURL -ID \u0026#34;KDE.Krita\u0026#34; -Name \u0026#34;Krita\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 139Get-WinGetPackageURL -ID \u0026#34;KDE.Okular\u0026#34; -Name \u0026#34;Okular\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 140Get-WinGetPackageURL -ID \u0026#34;Kitware.CMake\u0026#34; -Name \u0026#34;CMake\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 141Get-WinGetPackageURL -ID \u0026#34;LLVM.LLVM\u0026#34; -Name \u0026#34;LLVM\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 142Get-WinGetPackageURL -ID \u0026#34;Meltytech.Shotcut\u0026#34; -Name \u0026#34;Shotcut\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 143Get-WinGetPackageURL -ID \u0026#34;MHNexus.HxD\u0026#34; -Name \u0026#34;HxD\u0026#34; -Type \u0026#34;zip\u0026#34; -Class \u0026#34;Applications\u0026#34; 144Get-WinGetPackageURL -ID \u0026#34;Microsoft.VisualStudio.2022.Community\u0026#34; -Name \u0026#34;Microsoft_Visual_Studio_2022_Community\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 145Get-WinGetPackageURL -ID \u0026#34;Microsoft.VisualStudioCode\u0026#34; -Name \u0026#34;Microsoft_Visual_Studio_Code\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 146Get-WinGetPackageURL -ID \u0026#34;Mozilla.Firefox\u0026#34; -Name \u0026#34;Firefox\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 147Get-WinGetPackageURL -ID \u0026#34;Mozilla.Thunderbird\u0026#34; -Name \u0026#34;Thunderbird\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 148Get-WinGetPackageURL -ID \u0026#34;Musescore.Musescore\u0026#34; -Name \u0026#34;Musescore\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 149Get-WinGetPackageURL -ID \u0026#34;OBSProject.OBSStudio\u0026#34; -Name \u0026#34;OBSStudio\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 150Get-WinGetPackageURL -ID \u0026#34;Pinta.Pinta\u0026#34; -Name \u0026#34;Pinta\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 151Get-WinGetPackageURL -ID \u0026#34;Piriform.Recuva\u0026#34; -Name \u0026#34;Recuva\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 152Get-WinGetPackageURL -ID \u0026#34;RealVNC.VNCViewer\u0026#34; -Name \u0026#34;VNCViewer\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 153Get-WinGetPackageURL -ID \u0026#34;Rufus.Rufus\u0026#34; -Name \u0026#34;Rufus\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 154Get-WinGetPackageURL -ID \u0026#34;ShiningLight.OpenSSL\u0026#34; -Name \u0026#34;OpenSSL\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 155Get-WinGetPackageURL -ID \u0026#34;SSHFS-Win.SSHFS-Win\u0026#34; -Name \u0026#34;SSHFS\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 156Get-WinGetPackageURL -ID \u0026#34;Tencent.QQ\u0026#34; -Name \u0026#34;Tencent_QQ\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 157Get-WinGetPackageURL -ID \u0026#34;Tencent.TencentMeeting\u0026#34; -Name \u0026#34;Tencent_Meeting\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 158Get-WinGetPackageURL -ID \u0026#34;Tencent.WeChat\u0026#34; -Name \u0026#34;Tencent_WeChat\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 159Get-WinGetPackageURL -ID \u0026#34;TheDocumentFoundation.LibreOffice\u0026#34; -Name \u0026#34;LibreOffice\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 160Get-WinGetPackageURL -ID \u0026#34;TortoiseGit.TortoiseGit\u0026#34; -Name \u0026#34;TortoiseGit\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 161Get-WinGetPackageURL -ID \u0026#34;TortoiseHg.TortoiseHg\u0026#34; -Name \u0026#34;TortoiseHg\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 162Get-WinGetPackageURL -ID \u0026#34;TortoiseSVN.TortoiseSVN\u0026#34; -Name \u0026#34;TortoiseSVN\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 163Get-WinGetPackageURL -ID \u0026#34;uGetdm.uGet\u0026#34; -Name \u0026#34;uGet\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 164Get-WinGetPackageURL -ID \u0026#34;VideoLAN.VLC\u0026#34; -Name \u0026#34;VideoLAN_VLC\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 165Get-WinGetPackageURL -ID \u0026#34;vim.vim\u0026#34; -Name \u0026#34;GVIM\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 166Get-WinGetPackageURL -ID \u0026#34;voidtools.Everything\u0026#34; -Name \u0026#34;Everything\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 167Get-WinGetPackageURL -ID \u0026#34;WinFsp.WinFsp\u0026#34; -Name \u0026#34;WinFsp\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 168Get-WinGetPackageURL -ID \u0026#34;WiresharkFoundation.Wireshark\u0026#34; -Name \u0026#34;Wireshark\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 169Get-WinGetPackageURL -ID \u0026#34;XnSoft.XnConvert\u0026#34; -Name \u0026#34;XnConvert\u0026#34; -Type \u0026#34;exe\u0026#34; -Class \u0026#34;Applications\u0026#34; 170Get-WinGetPackageURL -ID \u0026#34;ZeroTier.ZeroTierOne\u0026#34; -Name \u0026#34;ZeroTier_One\u0026#34; -Type \u0026#34;msi\u0026#34; -Class \u0026#34;Applications\u0026#34; 171 172# 软件包计数：用于对照日志查缺补漏 173Write-Output \u0026#34;Total: $Script:PackageCount`n\u0026#34; | Tee-Object $Script:PackageList -Append 174Write-Output \u0026#34;Write-Output `\u0026#34;Total: `$Script:PackageLocalCount``n`\u0026#34;\u0026#34; | Out-File $Script:PackageScriptIWR -Append 175Write-Output \u0026#34;Write-Output `\u0026#34;Total: `$Script:PackageLocalCount``n`\u0026#34;\u0026#34; | Out-File $Script:PackageScriptSBT -Append 176Write-Output \u0026#34;Write-Output `\u0026#34;Total: `$Script:PackageLocalCount``n`\u0026#34;\u0026#34; | Out-File $Script:PackageScriptWCD -Append 177 178# 查看日志文件 179explorer \u0026#34;${env:LOCALAPPDATA}\\Packages\\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\\LocalState\\DiagOutputDir\u0026#34; 180Remove-Item \u0026#34;${env:LOCALAPPDATA}\\Packages\\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\\LocalState\\DiagOutputDir\\*\u0026#34; -Recurse -Force -Confirm 这段代码的作用是将指定好的软件包的信息从 WinGet 上爬取下来，并自动生成用于下载这些软件包的脚本。将此段代码复制另存为 Get-PackagesInfo.ps1 ，在 PowerShell 中跳转到脚本所在目录运行脚本，若遇到了权限问题，请用管理员权限打开 PowerShell 环境，并正确指定本地计算机的 PowerShell 执行策略 完成上述步骤，就可以在 PowerShell 环境下执行这个脚本了： .\\Get-PackagesInfo.ps1 执行后，脚本会自动从 WinGet 配置的源下载安装包的信息，稍等片刻\n运行完毕后，在当前目录会自动生成 3 个新的 PS 脚本，用于将 Get-PackagesInfo.ps1 这个脚本中指定的软件包按分类从 WinGet 源下载到 PackageInstallers 目录下的分类目录中 这三个脚本的功能完全一致，只是用于下载采用的实现不同：\n\u0026ldquo;Get-PackageInstallersIWR.ps1\u0026rdquo; 使用 cmdlet Invoke-WebRequest 下载\n\u0026ldquo;Get-PackageInstallersSBT.ps1\u0026rdquo; 使用 cmdlet Start-BitsTransfer 下载\n\u0026ldquo;Get-PackageInstallersWCD.ps1\u0026rdquo; 创建 System.Net.WebClient 对象下载 任选其一即可\nEND ","date":"2024-03-26T20:05:34+08:00","permalink":"http://localhost:1313/posts/winget%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"winget的基础配置与使用"},{"content":"极简markdown语法 标题 要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 (\u0026lt;\\h3\u0026gt;) (例如：### My Header)\n可选 还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 \u0026ndash; 号来标识二级标题。\n段落 要创建段落，请使用空白行将一行或多行文本进行分隔。\n换行 在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(或使用HTML语法的)。\n强调 粗体 要加粗文本，请在单词或短语的前后各添加两个星号（*内容*）或下划线（_内容_）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（这**是内**容）。\n斜体 要用斜体显示文本，请在单词或短语前后添加一个星号（*内容*）或下划线（_内容_）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。\n粗体\u0026amp;斜体 要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。\n引用 要创建块引用，请在段落前添加一个 \u0026gt; 符号\n多个段落的块引用 块引用可以包含多个段落。为段落之间的空白行添加一个 \u0026gt; 符号。\n1 \u0026gt; 第一段 2 \u0026gt; 3 \u0026gt; 第二段 嵌套块引用 块引用可以嵌套。在要嵌套的段落前添加一个 \u0026raquo; 符号\n1 \u0026gt; 一层引用 2 \u0026gt; 3 \u0026gt;\u0026gt; 二层引用 带有其它元素的块引用 块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。\n1 \u0026gt; #### The quarterly results look great! 2 \u0026gt; 3 \u0026gt; - Revenue was off the chart. 4 \u0026gt; - Profits were higher than ever. 5 \u0026gt; 6 \u0026gt; *Everything* is going according to **plan**. 列表 有序列表 要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n无序列表 无序列表 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表\n在列表中嵌套其他元素 要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。\n表格 要添加表，请使用三个或多个连字符（\u0026mdash;）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。\n1 | Syntax | Description | 2 | ----------- | ----------- | 3 | Header | Title | 4 | Paragraph | Text | 对齐 您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心\n分隔线语法 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (\u0026mdash;) 或下划线 (___) ，并且不能包含其他内容。\n链接语法 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：[超链接显示名](超链接地址 \u0026quot;超链接title\u0026quot;)\n对应的HTML代码：\u0026lt;a href=\u0026quot;超链接地址\u0026quot; title=\u0026quot;超链接title\u0026quot;\u0026gt;超链接显示名\u0026lt;/a\u0026gt;\n这是一个链接 [Markdown语法](https://markdown.com.cn)。\n给链接增加 Title 链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。\n这是一个链接 [Markdown语法](https://markdown.com.cn \u0026quot;最好的markdown教程\u0026quot;)\n网址和Email地址 使用尖括号可以很方便地把URL或者email地址变成可点击的链接。\n1 \u0026lt;https://markdown.com.cn\u0026gt; 2 \u0026lt;fake@example.com\u0026gt; 引用类型链接 引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。\n链接的第一部分格式 引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。\n尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。\n以下示例格式对于链接的第一部分效果相同：\n1[hobbit-hole][1] 2[hobbit-hole] [1] 链接的第二部分格式 引用类型链接的第二部分使用以下属性设置格式：\n放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。 链接的URL，可以选择将其括在尖括号中。 链接的可选标题，可以将其括在双引号，单引号或括号中。 以下示例格式对于链接的第二部分效果相同：\n可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。\n图片语法 要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。\n插入图片Markdown语法代码：![图片alt](图片链接 \u0026quot;图片title\u0026quot;)。\n对应的HTML代码：\u0026lt;img src=\u0026quot;图片链接\u0026quot; alt=\u0026quot;图片alt\u0026quot; title=\u0026quot;图片title\u0026quot;\u0026gt;\n链接图片 给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。\n转义字符语法 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。\n","date":"2024-03-22T21:00:20+08:00","permalink":"http://localhost:1313/posts/%E6%9E%81%E7%AE%80markdown%E8%AF%AD%E6%B3%95/","title":"极简markdown语法"},{"content":"欢迎来到我的博客 欢迎来到我的个人博客！这里是我分享技术见解和生活点滴的地方。\n关于我 我是一名机器人工程专业的学生，热爱编程、诗词和游戏。这个博客是我的小天地，我在这里记录我的学习历程和生活经历。\n联系方式 邮箱：syuchua@proton.me GitHub：github.com/syuchua 感谢您的访问，希望您喜欢我的博客！\n","date":"2023-12-14T17:30:22+08:00","permalink":"http://localhost:1313/posts/welcome/","title":"欢迎来到我的博客"}]